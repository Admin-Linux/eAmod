//===== Documentação rAthena ================================
//= rAthena Script Commands
//===== Por: ==================================================
//= rAthena Dev Team
//===== Última Atualização: ========================================
//= 20180718
//===== Descrição: =========================================
//= Um manual de referência para a linguagem de script rAthena.
//= Os comandos são classificados dependendo de sua funcionalidade.
//============================================================

Este documento é um manual de referência para todos os comandos e funções de script
disponível no rAthena. Não é um tutorial simples. Quando as pessoas dizem para você
"Leia a P**** Manual", eles querem dizer isso.

A informação foi principalmente adquirida através da pesquisa de como as coisas 
realmente funcionam no código-fonte do servidor, este foi escrito por muitas pessoas
ao longo do tempo, e muitos deles não falam inglês e nunca deixaram anotações - 
ou não estão disponíveis para comentários. Como tal, qualquer coisa escrita aqui pode 
não ser correto, é correto apenas para o melhor do nosso conhecimento, que é limitado.

Este não é um lugar para ensinar programação básica. Este documento não ensinará
você básica de programação por si só. É mais uma referência para quem tem
menos uma vaga idéia do que eles querem fazer e querem saber quais ferramentas eles têm
disponível para fazê-lo. Nós tentamos mantê-lo o mais simples possível, mas se você
não entender,  ter um livro claro sobre programação em geral ajudará melhor do que 
gritar pelo fórum por ajuda.

Um pouco de aprendizado nunca fez a cabeça de ninguém explodir.

Estrutura
---------
Os comandos e funções estão listados em nenhuma ordem específica:

* Nome do comando e como chamá-lo.

Texto descritivo

     Exemplo pequeno, se possível. Geralmente será incompleto, existe apenas para
     dar uma ideia de como funciona na prática.

Para encontrar um comando específico, use Ctrl + F, (ou qualquer tecla que chame uma pesquisa
função em tudo o que você está lendo isso com) colocar um * seguido pelo comando
nome, e deve encontrar a descrição do comando para você.

Se você encontrar alguma coisa omitida, responda. :)

Sintaxe
------

Ao longo deste documento, sempre que um comando deseja um argumento, ele é fornecido
<colchetes angulares>. Isso não significa que você deve digitar os "colchetes angulares". :) Se um
argumento de um comando é opcional, é dado em {chaves}. Você tem
sem dúvida vimos essa convenção em algum lugar, se você não se acostumar com isso,
saiba que os garotos grandes fazem isso. Se um comando pode, opcionalmente, tomar um não especificado
número de argumentos, você verá uma lista como esta:

command <argument>{,<argument>...<argument>}

Isso ainda significa que eles vão querer ser separados por vírgulas.

Onde um comando quer uma string, ele será dado em "aspas", se for um número,
será dado sem eles. Normalmente, você pode colocar uma expressão, como um monte
de funções ou operadores retornando um valor, em (parênteses) em vez da maioria
números. Os parênteses redondos nem sempre serão necessários, mas geralmente são bons
idéia.

Onde quer que você se refira a um nome de mapa, é sempre 'map name' ou 'map name.gat'
(embora o sufixo .gat esteja obsoleto).


Estrutura de carregamento de script
------------------------

Scripts são carregados pelo servidor de mapas como referenciado no 'conf / map_athena.conf'
arquivo de configuração, mas na configuração padrão, ele não carrega nenhum script
arquivos em si. Em vez disso, ele carrega o arquivo 'npc / scripts_main.conf' que
contém referências a outros arquivos. Os scripts reais são carregados do txt
arquivos, que estão ligados como este:

npc: <path to a filename>

Qualquer linha como essa, chamada, finalmente, por 'map_athena.conf' carregará o arquivo
script contido neste arquivo, o que tornará o script disponível. Nenhum arquivo
será carregado duas vezes, para evitar possíveis erros.

Outra opção de arquivo de configuração de relevância é:

delnpc: <path to a filename>

Isso descarregará um nome de arquivo de script especificado da memória, que, enquanto
aparentemente inútil, às vezes pode ser necessário.

Sempre que '//' é encontrado em uma linha ao ler, tudo além disso nessa
linha é considerada um comentário e é ignorada. Isso funciona onde quer que você
coloque-o.

// Esta linha será ignorada ao processar o script.

Bloquear comentários também pode ser usado, onde você pode colocar / * e * / entre qualquer
texto que você deseja que o rAthena ignore.

Exemplo:
/* Esse texto,
  * não importa qual nova linha você comece
  * é ignorado, até o seguinte
  * símbolo encontrado: */
 
Os asteriscos (*) na frente de cada linha são uma preferência pessoal e não são necessários.

Ao carregar todos os arquivos, o servidor executará todos os comandos de nível superior
neles. Nenhuma variável existe ainda neste momento, nenhum comando pode ser chamado além 
daqueles dados nesta seção. Esses comandos configuram o script básico da estrutura do
servidor - criar objetos NPC, criar objetos monstro, definir sinalizadores de mapa, etc. 
Nenhum código é realmente executado neste ponto, exceto eles. Os comandos de nível superior
do script são bastante confusos, uma vez que eles não são estruturados como você esperaria 
comandos, nome do comando primeiro, mas, normalmente, começam com um nome de mapa.

O que é mais confuso sobre os comandos de nível superior é que a maioria deles usa um
símbolo de tabulação para dividir seus argumentos.

Para evitar problemas e confusão, os símbolos de tabulação são gravados como '% TAB%'
ao longo deste documento, embora isso torne o texto um pouco menos legível.
Usando um símbolo invisível para denotar argumentos é uma das coisas ruins sobre
esta linguagem, mas estamos presos a isso por agora. :)

Aqui está uma lista de comandos válidos de nível superior:

** Definir um sinalizador de mapa:

<map name>%TAB%mapflag%TAB%<flag>

Isto irá, após o carregamento, definir um sinalizador de mapa especificado em um
mapa que você gosta. Esses são normalmente em arquivos dentro de 'npc / mapflag' 
e são carregados primeiro, então no momento em que o servidor está ativo, todos 
os mapas têm as flags que eles deveriam ter. Os sinalizadores de mapa determinam o 
comportamento do mapa em várias situações. Para mais detalhes, veja 'setmapflag'
e 'doc / mapflags.txt'.


** Criar um spawn de monstro permanente:

<map name>,<x>,<y>,<xs>,<ys>%TAB%monster%TAB%<monster name>%TAB%<mob id>,<amount>,<delay1>,<delay2>,<event>{,<mob size>,<mob ai>}

Map name é o nome do mapa em que os monstros irão aparecer. x, y são as
coordenadas onde a multidão deve aparecer. Se xs e ys forem diferentes de zero, eles
especificam o raio de uma área retangular de spawn centralizada em x, y.
Colocar zeros em vez dessas coordenadas gerará os monstros aleatoriamente.
Note que esta é apenas a zona de spawn inicial, como mobs random-walk, eles 
estão livres para se afastar de sua região de spawn especificada.

Monster name é o nome que os monstros terão na tela e não tem relação
qualquer que seja a seus nomes em qualquer outro lugar. É o id da multidão que conta, o que
identifica o registro do monstro no banco de dados 'mob_db.txt' dos monstros. Se o nome do mob
é dado como "--ja--", o campo 'japanese name' do banco de dados do monstro é
usado (que, no rAthena, na verdade contém um nome em inglês) se for "--en--",
é o 'english name'  do banco de dados do monstro (que contém nome maiúsculo
usado para chamar o monstro com um comando GM).

Amount  é a quantidade de monstros que serão gerados quando este comando é
executado, é afetado pelas taxas de spawn em 'battle_athena.conf'.

Delay1 e delay2 controlam os atrasos de renascimento dos monstros - o primeiro é o tempo
fixo de reabastecimento de base, e o segundo é a variância aleatória no topo do tempo base.
Ambos os valores são dados em milissegundos (1000 = 1 segundo).
Observe que o servidor também aplica um atraso de respawn mínimo de 5 segundos.

Você pode especificar um nível personalizado para usar para o mob diferente do de
o banco de dados ao lado do nível após o nome com uma vírgula. por exemplo:
"Poring, 50" para um nome irá gerar um monstro com o nome Poring e level 50.

Event é um evento de script a ser executado quando a multidão é morta. O evento deve
estar no formato "NPCName :: OnEventName" para executar e o rótulo do nome do evento
deve começar com "On". Como em todos os eventos, se o NPC for um NPC on-touch, o
O jogador que aciona o script deve estar dentro do intervalo de "disparo" para o evento
trabalhos.

Existem dois campos opcionais para tamanho de monstro e IA. O tamanho pode ser 0 (médio)
1 (pequeno) ou 2 (grande). AI pode ser 0 (padrão), 1 (ataque / amigável), 2 (esfera),
3 (flora) ou 4 (zanzou).

Como alternativa, um monstro gerado usando 'boss_monster' em vez de 'monster' é capaz 
de ser detectado no mapa com o status SC_BOSSMAPINFO (usado pelo Convex Mirror).

** Nomes de NPCs

/! \ AVISO: isso se aplica a warps, NPCs, duplicatas e lojas /! \

NPCs são um pouco especiais e são formatados desta maneira:
<Display name>{::<Unique name>}

Todos os NPCs precisam ter um nome exclusivo que seja usado para fins de identificação.
Quando você precisar identificar um NPC pelo nome, deverá usar <Unique name>.
Se <Unique name> não for fornecido, use <Display name>.

O cliente tem um recurso especial ao exibir nomes:
se o nome de exibição contiver um caractere '#', ele ocultará essa parte do nome.
ex: se o seu NPC é chamado 'Hunter # hunter1', ele será exibido como 'Hunter'

<Display name> deve ter no máximo 24 caracteres.
<Unique name>  deve ter, no máximo, 24 caracteres.

**  Defina um ponto de warp

<from mapname>,<fromX>,<fromY>,<facing>%TAB%warp%TAB%<warp name>%TAB%<spanx>,<spany>,<to mapname>,<toX>,<toY>

Isto irá definir um NPC warp que irá teleportar um jogador entre os mapas, e enquanto a maioria
argumentos de que são óbvios, alguns merecem menção especial.

SpanX e SpanY farão um warp sensível a um personagem que não deu um passo
diretamente sobre ele, mas entrou em uma zona que é centrada do warp de
coordena e é SpanX em cada direção através do eixo X e SpanY em cada
direção ao longo do eixo Y.

Warp NPC objects também tem um nome, porque você pode usá-lo para se referir a eles mais tarde
com 'enablenpc' / 'disablenpc'
Facing of a warp object is irrelevant, it is not used in the code and all 
current scripts have a zero in there.

** Defina um objeto NPC

<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,{<code>}
<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>,{<code>}

Isso colocará um objeto NPC em um mapa especificado no local especificado e
é um comando de nível superior que você usará mais em seu script personalizado. Os NPCs
são acionados clicando sobre eles, e / ou andando na área de disparo, se
definido, veja abaixo.

Facingé uma direção que o sprite NPC enfrentará. Nem todos os sprites NPC têm
imagens diferentes, dependendo da direção que você olha, por isso, para alguns frente
será sem sentido. As faces são contadas no sentido anti-horário em incrementos de 45
graus, onde 0 significa virado para o topo do mapa. (Então, para transformar o sprite
na parte inferior do mapa, você usa 4 e para fazer parecer sudeste
use 5.)

é o número do sprite usado para exibir este NPC em particular. Para um completo
lista de números de identidade de sprite, consulte http://kalen.s79.xrea.com/npc/npce.shtml.
também use o número de ID do monstro para exibir um sprite de monstro para este NPC.
É possível usar um  job sprite também, mas você deve primeiro defini-lo como um
monster sprite  em 'mob_avail.txt', uma descrição completa sobre como fazer isso não é
no escopo deste manual.
Um ID de sprite '-1' tornará o NPC invisível (e não clicável).
Um ID de sprite '111' fará um NPC que não tem um sprite, mas ainda é
clicável, o que é útil se você quiser fazer um objeto clicável do 3D
terreno.

TriggerX e triggerY, se dados, definirão uma área, centralizada em NPC e
abrangendo células triggerX em todas as direções em X e dispara em cada
direção em Y. Entrar nessa área irá disparar o NPC. Se não
'OnTouch:' special label está presente no código NPC, a execução será iniciada
desde o início do script, caso contrário, ele será iniciado a partir do 'OnTouch:'
rótulo. Monstros também podem acionar o NPC, embora o rótulo 'OnTouchNPC:' seja
usado neste caso.

A parte do código é o código de script que será executado sempre que o NPC for
desencadeada. Pode conter comandos e chamadas de função, cujas descrições
compor a maior parte deste documento. Tem que estar entre chaves, ao 
contrário de outros lugares onde usamos chaves, estes não significam um parâmetro opcional.

** Definir um 'floating' NPC object.

-%TAB%script%TAB%<NPC Name>%TAB%-1,{<code>}

Isso definirá um objeto NPC não acionável por meios normais. 
Isso normalmente significa que é inútil, já que não pode fazer nada, mas 
há exceções, principalmente relacionadas à execução de scripts em 
um horário especificado, para o qual são destinados esses floating NPC objects. 
Mais sobre isso abaixo.

** Definir a shop/cashshop/itemshop/pointshop NPC.

-%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}

-%TAB%cashshop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%cashshop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}

-%TAB%itemshop%TAB%<NPC Name>%TAB%<sprite id>,<costitemid>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%itemshop%TAB%<NPC Name>%TAB%<sprite id>,<costitemid>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}

-%TAB%pointshop%TAB%<NPC Name>%TAB%<sprite id>,<costvariable>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%pointshop%TAB%<NPC Name>%TAB%<sprite id>,<costvariable>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}

Isto irá definir uma loja NPC, que, quando acionada (o que só pode ser feito clicando)
fará com que uma vitrine apareça. Nenhum código é executado na loja
NPCs e você não pode mudar os preços senão editando o script
em si. (Não existem variáveis sequer neste momento de scripting, então nem mesmo
incomodar tentando usá-los.)

O item id é o número do item no banco de dados 'item_db.txt'. Se o preço estiver definido
para -1, o 'buy price' dado no banco de dados do item será usado. Caso contrário, o
preço que você deu será usado para este item, que é como você cria diferentes
preços para itens em diferentes lojas.

Desde que trunk r12264 você pode alternativamente usar "cashshop" no lugar de "shop"
para usar a interface Cash Shop, permitindo que você compre itens com pontos especiais
(Atualmente armazenado como conta vars em global_reg #CASHPOINTS e #KAFRAPOINTS.)
Este tipo de loja não lhe permitirá vender itens, você só pode
comprar itens aqui. O layout usado para definir itens de venda ainda conta e
"<price>" refere-se a quantos pontos serão gastos na compra dos mesmos.


Desde que trunk rX você pode alternativamente usar "itemshop" ou "pointshop" no lugar
de "shop" para usar a interface Shop, permitindo que você compre itens com um
item ou pontos especiais de uma variável. 'pointshop' suportava apenas tipos de variáveis
são variáveis de caracteres permanentes, variáveis temporárias de caracteres,
variáveis de conta local ou variáveis de conta globais permanentes. Essas variáveis
deve ser do tipo inteiro, não string. 'discount' flag é uma opção, faz o preço
nessa loja é afetada pela habilidade de desconto.

** Definir an warp/shop/cashshop/itemshop/pointshop/NPC duplicate.

warp: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<spanx>,<spany>
shop/cashshop/itemshop/pointshop/npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
shop/cashshop/itemshop/pointshop/npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>
npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>

Isto irá duplicar uma warp/shop/cashshop/itemshop/pointshop/NPC referida por 'label'.
Warp duplicates herdam o local de destino.
Shop/cashshop/itemshop/pointshop duplicates  herdam a lista de itens.
NPC duplicates herdam o código de script.
The rest (name, location, facing, sprite ID, span/trigger area)
é obtido a partir da definição duplicate (não herdada).

**Definir um função do objeto

function%TAB%script%TAB%<function name>%TAB%{<code>}

Isto irá definir um objeto de função, que pode ser chamado com o comando 'callfunc'
abaixo). Este objeto será carregado em cada map server separadamente, 
para que você possa acessá-lo de qualquer lugar. Não é possível chamar o
código neste objeto por algo diferente do comando de script 'callfunc'.

A parte code é o código de script que será executado sempre que a função for
chamado com 'callfunc'. Tem que estar entre chaves, ao contrário de outros lugares onde
nós usamos chaves, estas não significam um parâmetro opcional.

Uma vez definido um objeto que possui um campo 'code' para sua definição, 
ele contém comandos de script que podem ser acionados e executados.

~ RID? GID? ~

O que é um RID e por que você precisa saber
-----------------------------------------

A maioria dos comandos e funções de script desejará solicitar dados sobre um
char, armazene variáveis referenciadas a esse char, envie coisas para o
cliente conectado a esse char específico. Sempre que um script é invocado por um
char, é passado um chamado RID - este é o número de ID da conta de um
char que provocou o código para executar clicando nele, entrando em sua
Zona OnTouch, ou de outra forma.

Se você está escrevendo apenas NPCs comuns, não precisa se preocupar com isso. Contudo,
Se você usar funções, temporizadores, ativação de script baseada em relógio, você precisa
estar ciente de todos os casos em que uma execução de script será acionada sem um 
RID anexado. Isso tornará muitos comandos e funções inutilizáveis, já que eles querem 
dados de um char específico, querem enviar coisas para um cliente específico, querem 
armazenar variáveis específicas para esse char e  não saberão em que char trabalhar se não houver RID.

A menos que você use 'attachrid' para anexar explicitamente um char ao script primeiro.

Sempre que dizemos "invocando personagem", queremos dizer "o personagem que é RID é
anexado ao script em execução. A função de script "playerattached" pode ser
usado para verificar qual é o jogador atualmente conectado ao script (ele retornará 0 se não 
houver um player anexado ou o player anexado não estiver mais conectado ao servidor de mapas).

Mas e quanto a GID?
--- ---- ----- ----

GID significa o Game ID de algo, isso pode ser o GID obtido
através de mobspawn (comandos de controle mob) ou o ID da conta de um personagem.
Outra maneira seria clicar com o botão direito em um mob,
NPC ou char como GM sprited char para ver o GID.

Isso é usado principalmente para a nova versão de habilidade e os comandos 
de controle do mob implementados (mas NUNCA documentados pelo Lance. Que vergonha para você ...).

Scripts de itens e animais de estimação
--------------------

Cada item no banco de dados de itens tem três campos especiais - Script, OnEquip_Script
e OnUnequip_Script. O primeiro é o código de script executado toda vez que um personagem equipa o item,
com o RID do personagem que foi equipado. Toda vez que eles desequipam um item, todos
bônus temporários fornecidos pelos comandos de script são limpos e todos os scripts
são executados novamente para reconstruí-los. Isso também acontece em vários outras
situações (como no login), mas a lista completa é desconhecida.

OnEquip_Script é um pedaço de código de script executado sempre que o item é usado por um personagem
clicando duas vezes nele. OnUnequip_Script é executado sempre que o
o equipamento é desequipado por um personagem

Nem todos os comandos de script funcionam corretamente nos scripts de itens. Onde comandos e
funções são conhecidas por serem destinadas especificamente para uso em scripts de itens, 
elas são descritas como tal.

Cada animal de estimação no banco de dados do animal de estimação tem um campo PetScript, 
que determina o comportamento do animal de estimação. É invocado sempre que um animal de 
estimação do tipo especificado é gerado. (chocado de um ovo, ou carregado do servidor char 
quando um personagem que tinha o animal de estimação seguindo-os se conecta) Isso pode ocorrer 
em algumas outras situações também. Não espere nada além de comandos definitivamente marcados 
como utilizáveis ​​em scripts de estimação para trabalhar de forma confiável.

Números
-------

Além dos números decimais comuns, que não são nada de especial (embora
não espere usar frações, já que TODOS os números são inteiros neste idioma),
O mecanismo de script também manipula números hexadecimais, que são idênticos. 
Escrever um número como '0x <hex digits>' fará com que seja reconhecido como um 
valor hexadecimal. Observe que 0x10 é igual a 16. Observe também que, se você tentar 
'mes 0x10', ele imprimirá '16'.

Valores numéricos não podem exceder os limites de uma variável inteira: qualquer número 
maior que INT_MAX (2147483647) ou menor que INT_MIN (-2147483648) será limitado a 
esses valores e fará com que um aviso seja relatado.

Varíaveis
---------

A essência de toda linguagem de programação é variável - lugares onde você armazena
dados.

Na linguagem de script rAthena, os nomes de variáveis não diferenciam maiúsculas de minúsculas.

As variáveis são divididas e identificadas unicamente pela combinação de:
prefix - determina o escopo e a extensão (ou tempo de vida) da variável
name - um identificador que consiste em '_' e caracteres alfanuméricos
postfix - determina o tipo da variável: integer ou string

O escopo pode ser:
global - global para todos os servidores
local - local para o servidor
account  - anexado à conta do personagem identificado pelo RID
character - anexado ao personagem identificado por RID
npc - anexado ao NPC
scope  - anexado ao escopo da instância

A extensão pode ser:
permanent - Eles ainda existem quando o servidor é redefinido.
temporary - Eles deixam de existir quando o servidor é redefinido.

Prefix: escopo e extensão
nothing  - Uma variável permanente anexada ao personagem, o tipo de variável padrão.
           Eles são armazenados na tabela `global_reg_value` usando o tipo 3.
"@"      - Uma variável temporária anexada ao personagem.
           Versões SVN antes da revisão 2094 e versão RC5 também tratarão
           'l' como um prefixo de variável temporária, portanto, cuidado para ter variáveis
           nomes começando com 'l' se você quiser total compatibilidade com versões anteriores.
"$"      - Uma variável permanente global.
           Eles são armazenados na tabela de banco de dados `mapreg`.
"$@"     - Uma variável temporária global.
           Isso é importante para scripts que são chamados sem RID
           anexado, isto é, não acionado por um objeto de char específico.
"."      - Uma variável do NPC.
           Eles existem no NPC e desaparecem quando o servidor reinicia ou o
           NPC é recarregado. Pode ser acessado de dentro do NPC ou chamando
            'getvariableofnpc'. Objetos de função também podem ter variáveis ​​que 
	     são acessíveis dentro da função, no entanto 'getvariableofnpc' NÃO funciona 
            em objetos de função.
".@"     -  Uma variável de escopo.
           Eles são exclusivos da instância e do escopo. Cada instância tem seu
           próprio escopo que termina quando o script termina. Chamar uma função com
           callub / callfunc inicia um novo escopo, retornando da função termina. 
	    Quando um escopo termina, suas variáveis ​​são convertidas em valores
           ('return. @ var;' retorna um valor, não uma referência).
"'"      - Uma variável de instância
           Estes são usados ​​com o sistema de instanciação, e são únicos para cada
           instância da festa.
"#"      -  Uma variável de conta local permanente.
           Eles são armazenados na tabela `global_reg_value` usando o tipo 2.
"##"     - Uma variável de conta global permanente armazenada pelo servidor de login.
           Eles são armazenados na tabela `global_reg_value` usando o tipo 1.
           A única diferença que você notará das # variáveis ​​normais é quando
           você tem vários servidores de char conectados ao mesmo servidor de login.
           As # variáveis ​​são exclusivas para cada char server, enquanto as variáveis ​​## são
           são compartilhados por todos esses char server.

Postfix: integer or string
nothing - variável inteira, pode armazenar números positivos e negativos, mas apenas
          números inteiros (então não espere fazer nenhuma matemática fracionária)
'$'     - variável de string, pode armazenar texto

Exemplos:
  name  - variável inteira de caracteres permanentes
  name$ - variável de caracteres strings permanente
 @name  -  variável inteira de caráter temporário
 @name$ - variável de caracteres  string  temporária
 $name  - variável inteira global permanente
 $name$ - variável de string global permanente
$@name  - variável inteira global temporária
$@name$ - variável string global temporária
 .name  -  variável inteira NPC
 .name$ - variável de string NPC
.@name  - variável inteira do escopo
.@name$ - variável de string de escopo
 #name  - variável inteira de conta local permanente
 #name$ - variável permanente string da conta local
##name  - variável inteira de conta global permanente
##name$ - variável permanente string da conta global

Se uma variável nunca foi definida, considera-se igual a zero para variáveis ​​inteiras ou uma string vazia
 ("", nada entre as aspas) para variáveis ​​string. Depois de definir isso, a variável é tão boa quanto 
 esquecida para sempre, e nenhum vestígio permanece dela, mesmo se ela foi armazenada com dados
do personagem ou conta.


Algumas variáveis ​​são especiais, isto é, elas já estão definidas para você pelo mecanismo de script. 
Você pode ver a lista completa em algum lugar em 'db / const.txt', que é um arquivo que você deve 
ler, já que ele também permite que você substitua muitos argumentos numerados por muitos comandos 
com textos mais fáceis de ler. As variáveis ​​especiais mais usadas são todas as variáveis ​​baseadas em 
caracteres permanentes:

Zeny        - quantidade de Zeny.
Hp          - quantidade atual de pontos de vida.
MaxHp       - quantidade máxima de pontos de vida.
Sp          -  pontos de magia atuais.
MaxSp       - quantidade máxima de pontos de magia.
StatusPoint - Quantidade de pontos de habilidade restantes.
SkillPoint  - nível base do personagem.
BaseLevel   -  nível do trabalho do personagem.
JobLevel    - nível do trabalho do personagem.
BaseExp     - Quantidade de pontos de experiência de base.
JobExp      - Quantidade de pontos de experiência de trabalho.
NextBaseExp - Quantidade de pontos de experiência de base necessários para atingir o próximo nível.
NextJobExp  - Quantidade de pontos de experiência de trabalho necessários para atingir o próximo nível.
Weight      - Quantidade de peso que o personagem carrega atualmente.
MaxWeight   - Peso máximo que o personagem pode carregar.
Sex         -  0 se feminino, 1 se masculino.
Class       -  trabalho do personagem.
Upper       -  0 se o personagem for uma classe normal, 1 se for avançado, 2 se for bebê.
BaseClass   - O trabalho 1-1 'normal' do personagem, independentemente do valor Superior.
              Por exemplo, isso retornará Job_Acolyte para Acolyte, Priest/Monk,
              High Priest/Champion, e Arch Bishop/Sura. Se o personagem 
		não atingiu uma classe 1-1, ele retornará Job_Novice.
BaseJob     - O trabalho 'normal' do personagem, independentemente do valor Superior.
              Por exemplo, isso retornará Job_Acolyte para Acolyte,
              Baby Acolyte e High Acolyte.
Karma       - O carma do personagem. O sistema de karma não é totalmente funcional, mas
              isso não significa que isso não funcione. Não testado.
Manner      -  Classificação da maneira do personagem. Torna-se negativo se o jogador
              profere palavras proibidas através do uso de 'manner.txt' no lado do cliente
              Arquivo.

Embora estes se comportem como variáveis, nem sempre espere apenas defini-los - 
não é certo se isso funcionará para todos eles. Sempre que houver um comando ou uma 
função para definir algo, geralmente é preferível usá-lo. A exceção notável é a Zeny, que 
você pode e muitas vezes será sobrescrita diretamente - a configuração fará com que o personagem 
possua esse número de Zeny. Se você tentar definir o Zeny para um número negativo,
o script será encerrado com um erro.

Algumas constantes source-end também podem ser acessadas em scripts. 
Esta lista está localizada em 'src / map / script.c' na função 'script_hardcoded_constants', 
que contém constantes como opções de servidor e status:

    PACKETVER, MAX_LEVEL, MAX_STORAGE, MAX_INVENTORY, MAX_CART, MAX_ZENY, MAX_PARTY,
    MAX_GUILD, MAX_GUILDLEVEL, MAX_GUILD_STORAGE, MAX_BG_MEMBERS, MAX_CHAT_USERS,
    VIP_SCRIPT, MIN_STORAGE

    Option_Nothing, Option_Sight, Option_Hide, Option_Cloak, Option_Falcon, Option_Riding,
    Option_Invisible, Option_Orcish, Option_Wedding, Option_Chasewalk, Option_Flying,
    Option_Xmas, Option_Transform, Option_Summer, Option_Dragon1, Option_Wug,
    Option_Wugrider, Option_Madogear, Option_Dragon2, Option_Dragon3, Option_Dragon4,
    Option_Dragon5, Option_Hanbok, Option_Oktoberfest, Option_Dragon, Option_Costume

Atribuindo Variáveis
--------- ---------

A partir da revisão do rAthena 15982, as variáveis podem ser acessadas e atribuídas diretamente 
aos valores sem o uso da função 'set' incorporada. Isso significa que as variáveis podem ser 
acessadas e modificadas de maneira semelhante a outras linguagens de programação.

    @x = 100;
    @x = @y = 100;

O suporte para modificar valores de variáveis usando 'set' ainda é suportado 
(e é necessário que exista para que este novo método funcione) para que os scripts 
anteriores continuem a funcionar.

Ao atribuir valores, todos os métodos do operador são suportados, os quais existem na seção abaixo
'Operadores'. Por exemplo:

    @x += 100;
    @x -= 100;
    @x *= 2;
    @x /= 2;
    @x %= 5;
    @x >>= 2;
    @x <<= 2;

Tudo vai funcionar? Para obter mais informações sobre operadores disponíveis, consulte a seção Operadores
descrita abaixo. Todos os operadores listados podem ser colocados na frente do sinal '=' ao 
modificar variáveis para executar a ação conforme necessário.

Nota:

 !! Atualmente, o mecanismo de script não suporta copiar diretamente as variáveis array.
 !! Para copiar arrays entre variáveis, o uso da função 'copyarray' ainda é
 !! requerido.

Strings
-------

Para incluir o símbolo '"' em uma string, você deve usar o prefixo '\"'


Arrays
------

Arrays (pelo menos em rAthena) são essencialmente um conjunto de variáveis ​​que estão 
sob o mesmo nome. Você pode dizer entre as variáveis ​​específicas de uma 
array com um 'array index', um número de uma variável nessa array:

<variable name>[<array index>]

As variáveis ​​armazenadas dessa maneira, dentro de uma array, também são 
chamadas de 'array elements'. Os arrays são especificamente úteis para 
armazenar um conjunto de dados semelhantes (como vários IDs de item, por exemplo) 
e, em seguida, percorrê-lo. Você pode endereçar qualquer varíavel array
como se fosse uma variável normal:

    set @arrayofnumbers[0],1;

Você também pode fazer coisas sorrateiras, como usar uma variável (ou uma expressão, ou até mesmo uma
valor de uma outra array) para obter um valor de array:

    set @x,100;
    set @arrayofnumbers[@x],10;
    
Isso fará com que @arrayofnumbers [100] seja igual a 10.

Observe que a numeração de índice sempre começa com 0. Arrays não podem conter mais de
128 variáveis. (Então o último não pode ter um número maior que 127)


E os índices de array provavelmente não podem ser negativos. Ninguém testou o que acontece quando
você tenta obter uma variável numerada negativamente de uma array, mas não vai
ser bonita. :)

Arrays podem armazenar naturalmente strings:

@menulines$[0]é o 0º elemento da matriz @menulines$ de strings. Aviso prévio
o '$', normalmente denotando uma variável de string, antes dos colchetes que
denota um array index

Resumo da variável permitida e escopos de array
------ -- --- ------- -------- --- ----- ------

+==========+======+=======+
|VarType   | Norm | Array |
+==========+======+=======+
|$Str$     | OK!  | OK!   |
+----------+------+-------+
|$@Str$    | OK!  | OK!   |
+----------+------+-------+
|@Str$     | OK!  | OK!   |
+----------+------+-------+
|#Str$     | OK!  | FAIL! |
+----------+------+-------+
|Str$      | OK!  | FAIL! |
+----------+------+-------+
|$Int      | OK!  | OK!   |
+----------+------+-------+
|$@Int     | OK!  | OK!   |
+----------+------+-------+
|@Int      | OK!  | OK!   |
+----------+------+-------+
|#Int      | OK!  | FAIL! |
+----------+------+-------+
|Int       | OK!  | FAIL! |
+----------+------+-------+
|.Str$     | OK!  | OK!   |
+----------+------+-------+
|.Int      | OK!  | OK!   |
+----------+------+-------+
|.@Str$    | OK!  | OK!   |
+----------+------+-------+
|.@Int     | OK!  | OK!   |
+----------+------+-------+

Referências Variáveis
-------------------

//##TODO



Operadores
---------

Operadores são coisas que você pode fazer com variáveis ​​e números. Eles são ou
operações matemáticas comuns ou operadores condicionais

	+ - adicionará dois números. Se você tentar adicionar duas strings, o resultado será um
	    corda colada junto no +. Você pode adicionar um número a uma string e
	    resultado será uma string. Nenhum outro operador matemático trabalha com strings.
	- - subtrairá dois números.
	* - irá multiplicar dois números.
	/ - vai dividir dois números. Note que esta é uma divisão inteira, ou seja,
	    7/2 não é igual a 3,5, é igual a 3.
	% - lhe dará o restante da divisão. 7% 2 é igual a 1.

Existem também operadores condicionais. Isso tem a ver com o comando condicional 'if' e 
eles devem retornar 1 se a condição for satisfeita e 0 se não for. (Isso é o que eles chamam 
de variáveis ​​'booleanas'. 0 significa 'Falso'. Qualquer coisa, exceto o zero, é 'Verdadeiro'). 
Ímpar como é, -1 e -5 e qualquer coisa abaixo de zero também será Verdadeiro.

Você pode comparar números entre si e comparar cadeias entre si, mas não pode comparar números a cadeias de caracteres.

	 == - É verdade se ambos os lados são iguais. Para seqüências de caracteres, isso significa que elas são iguais.
	 >= - Verdadeiro se o primeiro valor for igual ou maior que o segundo valor.
	 <= - Verdadeiro se o primeiro valor for igual ou menor que o segundo valor
	 > - Verdadeiro se o primeiro valor for maior que o segundo valor
	 <- Verdadeiro se o primeiro valor for menor que o segundo valor
	 != - Verdadeiro se o primeiro valor NÃO é igual ao segundo

Exemplos:

		1 == 1 é verdadeiro.
		1 <2 é verdadeiro enquanto 1> 2 é falso.
		@x> 2 é True se @x for igual a 3. Mas não é verdade se @x for 2.

Somente '==' e '! =' Foram testados para comparar strings. Já que não tem jeito
codificar uma estrutura de dados seriamente complexa nesse idioma, tentando classificar
seqüências de caracteres pelo alfabeto seria inútil de qualquer maneira.

As comparações podem ser empilhadas na mesma condição:

		&& - É verdadeiro se e somente se ambos os lados forem verdadeiros.
		('1 == 1 && 2 == 2' é verdadeiro. '2 == 1 && 1 == 1' é falso.)
		|| - É True se um dos lados dessa expressão for Verdadeiro.

 1==1 && 2==2 is True.
 1==1 && 2==1 is False.
 1==1 || 2==1 is True.

Exemplos:

	 1 == 1 é verdadeiro.
	 1 <2 é verdadeiro enquanto 1> 2 é falso.
	 @x> 2 é True se @x for igual a 3. Mas não é verdade se @x for 2.

Somente '==' e '! =' Foram testados para comparar strings. Já que não tem jeito
codificar uma estrutura de dados seriamente complexa nesse idioma, tentando classificar
seqüências de caracteres pelo alfabeto seria inútil de qualquer maneira.

As comparações podem ser empilhadas na mesma condição:

	 && - É verdadeiro se e somente se ambos os lados forem verdadeiros.
	      ('1 == 1 && 2 == 2' é verdadeiro. '2 == 1 && 1 == 1' é falso.)
	 || - É True se um dos lados dessa expressão for Verdadeiro.

 1 == 1 && 2 == 2 é verdadeiro.
 1 == 1 && 2 == 1 é False.
 1 == 1 || 2 == 1 é verdadeiro.

Operadores bit a bit lógicos funcionam somente em números e são os seguintes:

	 << - Esquerda.
	 >> - Deslocamento à direita.
		Deslocamento à esquerda move o binário 1 (s) de um número n posições para a esquerda,
		que é o mesmo que multiplicar por 2, n vezes.
		Por outro lado, o deslocamento para a direita move o binário 1 (s) de um número n posições
		para a direita, que é o mesmo que dividir por 2, n vezes.
			Exemplo:
				set b,2;
				set a, b << 3;
				mes a;
				set a, a >> 2;
				mes a;
		O primeiro comando mes exibiria 16, que é o mesmo que 2 x (2 x 2 x 2) = 16.
		O segundo comando mes exibirá 4, que é o mesmo que 16/2 = 8. 8/2 = 4.
& - E.
| - ou
	O operador bitwise AND (&) é usado para testar dois valores um contra o outro,
	e resulta na definição de bits que estão ativos em ambos os argumentos. Isso pode
	ser usado para algumas coisas, mas no rAthena este operador é geralmente usado para
	crie bit-masks em scripts.

	O operador bitwise OR (|) define para 1 uma posição binária se a posição binária
	de um dos números é 1. Desta forma, uma variável pode conter vários valores que podemos verificar,
	conhecido como bit-mask. Atualmente, uma variável pode conter até 32 máscaras de bits (da posição 0
	para a posição 1). Esta é uma maneira barata (skate) e fácil de evitar o uso de arrays para armazenar vários checks
	que um jogador pode ter.

	Uma máscara de bits basicamente está (ab)usando as variáveis ​​bits para definir várias opções
	numa variável. Com o limite atual, se variáveis ​​é possível armazenar 32
	diferentes opções em uma variável (usando os bits na posição 0 a 31).

		Exemplo(s):
		- Exemplo básico do operador &, exemplo de bit:
			10 & 2 = 2
		Por quê? :
			10 = 2 ^ 1 + 2 ^ 3 (2 + 8), portanto, em bits, seria 1010
			2 = 2 ^ 1 (2), então em bits (mesmo tamanho) seria 0010
			O operador & (AND) define bits que estão ativos (1) em ambos os argumentos, portanto,
			exemplo 1010 & 0010, somente o bit 2 ^ 1 está ativo (1) em ambos. Resultando no bit
			0010, que é 2.
		- Exemplo básico de criação e uso de uma máscara de bits:
			set @options,2|4|16;  // (nota: isso é o mesmo que 2 + 4 + 16 ou 22)
			if (@options & 1)	mes "A opção 1 está ativada";
			if (@options & 2) mes "A opção 2 está ativada";
			if (@options & 4) mes "A opção 3 está ativada";
			if (@options & 8) mes "A opção 4 está ativada";
			if (@options & 16) mes "A opção 5 está ativada";
		Isso retornaria as mensagens sobre as opções 2, 3 e 5 sendo mostradas (já que definimos
		o 2,4 e 16 bits para 1).
 ^  - Xor.
		O operador bitwise  XOR (eXclusive OR) define uma posição binária para 0 se ambos
		números têm o mesmo valor na dita posição. Por outro lado,
		define para 1 se eles tiverem valores diferentes na referida posição binária.
		Esta é outra maneira de configurar e desfazer bits em máscaras de bit.

		Exemplo:
		- Primeiro, vamos definir as missões que estão atualmente em progresso:
			set inProgress,1|8|16; // quest 1,8 e 16 estão em andamento
		- Depois de jogar um pouco, o jogador começa outra missão:
			if( inProgress&2 == 0 ){
				// isso irá definir o bit da quest 2 (inProgress tem o bit definido como 0)
				set inProgress,inProgress^2;
				mes "Missão 2: encontre um novato e seja útil para ele por uma hora.";
				close;
			}
		- Depois de passar algum tempo lendo informações no Xor's, o jogador finalmente completa a quest 1:
			if( inProgress&1 && isComplete ){
				// isso irá cancelar o bit da quest 1 (inProgress tem o bit definido como 1)
				set inProgress,inProgress^1;
				mes "Missão 1 completa !! Você desvendou os segredos da dinastia Xor, use-os sabiamente.";
				close;
			}

Operadores unários com apenas um único número, que segue o operador, e
estão seguindo:

 -  - Negação.
	O sinal do número será invertido. Se o número for positivo, será
	tornar-se negativo e vice-versa.

	Exemplo:
		set .@myvar,10;
		mes "Negativo 10 é "+(-.@myvar);

 !  - Não lógico.
	Inverte o resultado booleano de uma expressão. Verdadeiro se tornará falso e
	falso se tornará verdadeiro.

	Exemplo:
		if(!callfunc("F_dosomething"))
		{
			mes "Fazer algo falhou.";
			close;
		}

 ~  - Bitwise Not.
	Inverte cada bit em um número, também conhecido como complemento de um. Bits desobstruídos
	são definidos e os bits definidos são apagados.

	Exemplo:
	- Assegure-se de que a quest 2 esteja desabilitada, mantendo todas as outras ativas, se estiverem.
		set inProgress,inProgress&(~2);  // o mesmo que set inProgress, inProgress & 0xfffffffd

Os operadores ternários usam três expressões (números, cadeias de caracteres ou booleanas) e estão seguindo:

 ?: - Operador condicional
	Muito útil, por exemplo para substituir

		if(Sex) mes "..."; else mes "...";

	cláusulas com simples

		mes  "Bem-vindo," + (Sexo? "Senhor": "Sra.")  + " " + strcharinfo(0);

	ou para substituir qualquer outra cláusula if-else simples. Pode valer a pena
	mencionando isso ?: tem baixa prioridade e tem que ser incluído com
	parênteses na maioria dos casos (se não todos).

Labels
------

Dentro do código de script executável, algumas linhas podem ser labels:

<label name>:

Labels são pontos de referência no seu script, que podem ser usados ​​para rotear
execução com comandos 'goto', 'menu' e 'jump_zero', invocados com comandos 'doevent' 
e 'donpcevent' e são essenciais. O nome de um marcador não pode ter mais de 22 caracteres. 
(23 é o ':'.) Há alguma confusão na fonte sobre se é 22, 23 ou 24 em todo o lugar, então 
manter rótulos com menos de 22 caracteres pode ser sábio. Pode conter apenas caracteres 
alfanuméricos e sublinhados. Além das labels que você nomeia, há também algumas labels
especiais com os quais o mecanismo de script começará a execução 
se um evento especial ocorrer:

OnClock<hora><minuto>:
OnMinute<minuto>:
OnHour<hora>:
On<weekday><hora><minuto>:
OnDay<mês><dia>:

Isso será executado quando o relógio do servidor atingir a data ou a hora especificada. Horas
e minutos são dados no tempo militar. ('0105' significa 01:05 AM). Dias da semana
são Sun,Mon,Tue,Wed,Thu,Fri,Sat. Os meses são 01 a 12, os dias são 01 a 31.
Lembre-se do zero. :)

OnInit:
OnInterIfInit:
OnInterIfInitOnce:

OnInit será executado toda vez que o carregamento dos scripts for concluído, 
inclusive quando forem recarregados com o comando @reloadscript. 
OnInterIfInit será executado quando o map server se conectar a um char server, 
OnInterIfInitOnce será executado apenas uma vez e não será executado se
o map server se reconectar ao char server posteriormente.


OnAgitStart:
OnAgitEnd:
OnAgitInit:
OnAgitStart2:
OnAgitEnd2:
OnAgitInit2:

OnAgitStart será executado sempre que o servidor mudar para o modo WoE, seja ele
feito com o comando @agitstart GM ou com o comando de script 'AgitStart'. OnAgitEnd
fará o mesmo para o final do WoE.

OnAgitInit será executado quando os dados de todos os castelos e todas as guildas 
que possuem um castelo forem recebidos pelo map server a partir do char server 
após a conexão inicial.

Nenhum RID será anexado enquanto qualquer uma das labels mencionadas acima for 
acionada, portanto, nenhuma variável baseada em personagem ou conta será acessível, 
até que você conecte um RID com 'attachrid' (veja abaixo).

Os acimas também se aplicam aos últimas três labels, a única diferença é que
essas labels são usados ​​exclusivamente para o WoE SE e são chamadas independentemente.

OnInstanceInit:

Essa label será executada quando uma instância for criada e inicializada por meio do comando 'instance_create'. 
Ela será executado novamente se @reloadscript for usado enquanto uma instância estiver em andamento.

OnTouch:

Esta label será executada se uma área de disparo estiver definida para o objeto NPC em que está. 
Se não estiver presente, a execução será iniciada a partir do início do código NPC. 
O RID do objeto do personagem acionador será conectado.

OnTouch_:

Semelhante ao OnTouch, mas só executará uma instância. 
Outro personagem é escolhido uma vez que o personagem desencadeador deixa a área.

OnTouchNPC:

Semelhante ao OnTouch, mas só irá disparar para monstros.

OnPCLoginEvent:
OnPCLogoutEvent:
OnPCBaseLvUpEvent:
OnPCJobLvUpEvent:

É bastante óbvio quando essas quatro labels especiais serão invocadas.

OnPCDieEvent:

Esta label especial dispara quando um jogador morre. A variável 'killerrid' é
definida para o ID do assassino.

OnPCKillEvent:

Esta label especial é acionada quando um jogador mata outro jogador. A variável
'killrid' é definido como o ID do jogador morto.

OnNPCKillEvent:

Esta label especial dispara quando um jogador mata um monstro. A variável
'killrid' é definida para a classe (mob ID) do monstro morto.

OnPCLoadMapEvent:

Esta label especial é acionada quando um jogador entra em um mapa marcado com o 
mapflag 'loadevent' e anexa seu RID. O fato de que esta label requer um mapflag para 
que ele funcione é porque, caso contrário, ele estaria em todo o servidor e seria acionada toda 
vez que um jogador mudasse de mapa. Imagine a carga do servidor com 1.000 jogadores (oh a dor ...)

OnPCStatCalcEvent:

Essa label especial é acionada quando as estatísticas de um jogador são recalculadas, 
como ao alterar estatísticas, equipamentos ou mapas, bem como ao fazer login, subir de nv e upar 
de job. Isso pode ser usado para conceder bônus de itens adicionais 
a determinados grupos de jogadores, por exemplo.

OnWhisperGlobal:

Esta label especial dispara quando um jogador sussurra o NPC, e executará com o
RID do jogador anexado. Pode aceitar até dez parâmetros, que serão armazenados
em variáveis ​​string de char temporários separados @whispervar0$ a @whispervar9$.
Veja 'doc / whisper_sys.txt' para documentação adicional.

Apenas as labels especiais que não estão associadas a nenhum comando de script são 
listadas aqui. Existem outros tipos de labels que podem ser acionados de maneira 
semelhante, mas são descritos com seus comandos associados.

On<label name>:

Essas labels especiais são usados ​​principalmente com scripts Mob e comandos 
de script que requerem que você aponte/vincule um comando a um mob ou a um outro 
NPC, fornecendo um nome para label para iniciar. O nome da label pode ser 
do seu agrado, mas deve ser

Exemplo:

monster "prontera",123,42,"Poringz0rd",2341,23,"Master::OnThisMobDeath";

amatsu,13,152,4	script	Master	767,{
	mes "Olá";
	close;

OnThisMobDeath:
	announce "Hey, "+strcharinfo(0)+" acabou de matar um Poringz0rd!!",bc_blue|bc_all;
	end;
}

Cada vez que você mata um, esse anúncio aparecerá em azul para todos.

"Global" labels

Há uma captura com labels e doevent. Se você chamar uma label (usando doevent) 
e a label chamada estiver num NPC que tem área de gatilho, essa label deve terminar 
com "Global" para funcionar globalmente (ou seja, se o RID estiver fora da área de gatilho, 
o que geralmente acontece, não adianta chamar a label com doevent, 
porque OnTouch faria o trabalho). Para referência adicional, procure por npc_event em npc.c.

Comandos e funções de script
--------------------------------

Os comandos e funções estão listados aqui em nenhuma ordem particular. Há uma
diferença entre comandos e funções - os comandos não deixam nenhum 'valor de retorno' 
que pode ser usado em uma instrução condicional, como um argumento de comando, 
ou armazenado em uma variável. Chamar comandos como se fossem funções, 
por vezes, funcionará, mas não é aconselhável, pois isso pode levar a alguns erros 
difíceis de rastrear. Chamar funções, como se fossem comandos, atrapalharão 
a pilha, portanto, o comando 'return' não retornará corretamente depois que isso
acontecer em um script específico.

Todos os comandos devem terminar com um ';'. Na verdade, 
você pode esperar ter vários comandos em uma linha se terminar corretamente 
com um ';', mas é melhor não usá-lo, já que não é certo se o mecanismo de 
script se comportará bem se você fizer isso.

-------------------------


A partir daqui, teremos os comandos classificados da seguinte forma:

1.- Comandos básicos.
2.- Comandos de recuperação de informação.
3.- Comandos de checagem.
4.- Comandos relacionados ao jogador.
5.- Comandos relacionados à Mob / NPC.
6.- Outros comandos
7.- Comandos de instância.
8.- Comandos do Log de Missão.
9.- Comandos de battleground.
10.- Comandos de pet.
11.- Comandos do homunculus.
12.- Comandos mercenários.
13.- Comandos de party .

=====================
|1.- Comandos básicos.|
=====================
---------------------------------------

*mes "<string>"{,"<string>"{,...}};

Esse comando exibirá uma caixa na tela para o personagem invocado, 
se essa caixa já não estiver exibida, e imprimirá a string especificada nessa caixa. 
Normalmente, não há nenhum botão 'fechar' ou 'próximo' nesta caixa, a menos que você 
crie um com 'fechar' ou 'próximo' e, enquanto estiver aberto, o player não poderá fazer 
muito mais, por isso é importante criar um botão mais tarde . Se a string 
estiver vazia, aparecerá como uma linha vazia.

    mes "Texto que aparecerá na caixa";

Cores
------
Dentro da string você pode colocar códigos de cores, que irão alterar a cor do texto impresso 
depois deles. Os códigos de cores são todos '^ <R> <G> <B>' e contêm três números hexadecimais 
representando as cores como se fossem cores HTML - ^ FF0000 é vermelho brilhante, ^ 00FF00 
é verde brilhante, ^ 0000FF é azul brilhante, ^ 000000 é preto. ^ FF00FF é um magenta puro, 
mas também é uma cor que é considerada transparente sempre que o cliente desenha janelas 
na tela, portanto, a impressão de texto nessa cor terá um efeito meio estranho. Depois de 
definir a cor de um texto para algo, é preciso defini-lo novamente para preto, a menos que
você queira que todo o restante do texto esteja nessa cor:

     mes "Isto é ^FF0000 vermelho ^000000 e este é ^00FF00 verde, ^000000 assim.";
    
Observe que a coloração do texto é tratada apenas pelo cliente. Se você usar caracteres 
que não sejam em inglês, os códigos de cores poderão ser corrompidos se eles se prenderem 
a letras sem espaço intermediário. Separá-los com espaços das letras de cada lado resolve o problema.

Várias linhas
--------------
Para exibir várias linhas de mensagem enquanto estiver usando apenas 
um único comando 'mes', use o comando script no seguinte formato:

    mes "Linha 1", "Linha 2", "Linha 3";

Isso exibirá 3 linhas diferentes enquanto consome apenas uma única linha no arquivo de script relevante.

Navegação
----------
Para clientes datados de 2011-10-10aRagexe em diante, você pode gerar links de navegação
usando labels semelhantes a HTML:

    <NAVI>Nome de exibição<INFO>mapname,x,y,0,000,flag</INFO></NAVI>

O parâmetro "flag" pode ser:
 0: não abre a janela de navegação (padrão).
 1: Abra a janela de navegação.

O exemplo abaixo fará com que o texto [Tool Shop] seja clicável e inicie a navegação
para alberta (98,154) quando clicado.

    mes "Você verificou a <NAVI>[Tool Shop]<INFO>alberta,98,154,0,000,0</INFO></NAVI>?";

URLs
----
Da mesma forma, você pode criar links para sites que são iniciados em uma nova janela:

    <URL>Nome de exibição<INFO>http://www.example.com/</INFO></URL>";

---------------------------------------

*next;

Esse comando exibirá um botão 'next' na janela de mensagens para o jogador. 
Clicar nele fará com que a janela seja apagada e exiba uma nova. 
Usado para segmentar NPC-falante, next é frequentemente usado 
em combinação com 'mes' e 'close'.

Se nenhuma janela estiver atualmente na tela, uma será criada, 
mas assim que o jogador clicar nela, um aviso 
será lançado no console do servidor e o script será encerrado.

    mes "[Woman]";
    mes "Isso apareceria na página";
    next;
    //  Isso é necessário, pois é uma nova página e o topo agora ficará em branco
    mes "[Woman]";
    mes "Isso apareceria na segunda página";

---------------------------------------

*close;

Este comando irá criar um botão 'close' na janela de mensagens para o jogador.
Se nenhuma janela estiver atualmente na tela, a execução do 
script terminará. Esta é uma das maneiras de terminar um discurso de um NPC. 
Quando o botão for clicado, a execução do script NPC terminará e a caixa de mensagem desaparecerá.

    mes "[Woman]";
    mes "Eu terminei de falar com você. Clique no botão fechar.";
    close;
    mes "Este comando não será executado, já que o script terminou.";

---------------------------------------

*close2;

Este comando irá criar um botão 'close' na janela de mensagens para o jogador.
AVISO: Se nenhuma janela estiver atualmente na tela, 
a execução do script será interrompida indefinidamente! Veja "close". 
Há uma diferença importante - embora a caixa de mensagem seja fechada, 
a execução do script não será interrompida e os comandos depois de 'close2' ainda 
serão executados, significando que um 'end' deve ser usado para parar o 
script, a menos que você o faça parar de alguma outra maneira.

    mes "[Woman]";
    mes "Vou te teleportar agora..";
    close2;
    warp "place",50,50;
    end;
    
Não espere que as coisas corram bem se você não fizer com que seus scripts 'finalizem'.

---------------------------------------

*end;

Esse comando interromperá a execução deste script específico. 
As duas versões são perfeitamente equivalentes. 
É o caminho normal para terminar um script que não usa 'mes'.

        if (BaseLevel<=10) goto L_Lvl10;
        if (BaseLevel<=20) goto L_Lvl20;
        if (BaseLevel<=30) goto L_Lvl30;
        if (BaseLevel<=40) goto L_Lvl40;
        if (BaseLevel<=50) goto L_Lvl50;
        if (BaseLevel<=60) goto L_Lvl60;
        if (BaseLevel<=70) goto L_Lvl70;
    L_Lvl10:
        npctalk "Veja que você ainda é um n00b";
        end;
    L_Lvl20:
        npctalk "Veja que você está melhorando, mas ainda é um n00b";
        end;
    L_Lvl30:
        npctalk "Olha que você está chegando lá, você está quase na segunda profissão agora certo ???";
        end;
    L_Lvl40:
        npctalk "Olha que você é quase segunda profissão";
        end;

Sem o uso de 'end', passaria pelas labels até o final do script. 
Se você fosse lvl 10 ou menos, você veria todas as linhas de fala,
o uso de 'end' parará e terminará o script.

---------------------------------------

*set <variable>,<expression>;
*set(<variable>,<expression>)

Este comando irá definir uma variável para o valor que a expressão resulta.
As variáveis ​​podem ser definidas por meio desse comando ou diretamente, 
como qualquer outra linguagem de programação (consulte a seção "Atribuindo variáveis").

Este é o comando de script mais básico e é muito usado sempre que você tenta fazer
qualquer coisa mais avançada do que apenas imprimir texto em uma caixa de mensagem.

    set @x,100;
    
fará com que @x seja igual a 100.

    set @x,1+5/8+9;
    
calculará 1 + 5/8 + 9 (o que é, surpreendentemente, 10 - lembre-se, todos os números são
inteiro nesta língua) e fará @x igual a antes.

Retorna a referência da variável (desde trunk r12870).

---------------------------------------

*setd "<variable name>",<value>;

Funciona quase identicamente como set, exceto que o nome da variável é identificado como uma string
e pode assim ser construído dinamicamente.

Este comando é equivalente a:
  set getd("variable name"),<value>;

Exemplos:

  setd ".@var$", "Poporing";
  mes .@var$;  // Exibe "Poporing".

  setd ".@" + .@var$ + "123$", "Poporing é legal";
  mes .@Poporing123$;  // Exibe "Poporing é legal".


---------------------------------------

*getd("<variable name>")

Retorna uma referência a uma variável, o nome pode ser construído dinamicamente.
Consulte 'setd' para uso.

Isso também pode ser usado para definir um array dinamicamente:
  setarray getd(".array[0]"), 1, 2, 3, 4, 5;

Exemplos:

  set getd("$varRefence"), 1;
  set @i, getd("$" + "pikachu");

---------------------------------------

*getvariableofnpc(<variable>,"<npc name>")

Retorna uma referência a uma variável NPC (. prefix) do NPC de destino.
Isso só pode ser usado para obter. variáveis.

Exemplos:

// Isso retornará o valor de .var, note que isso não pode ser usado, já que o valor não é capturado.
	getvariableofnpc(.var,"TargetNPC");
	
// Isso definirá a variável .v com o valor da variável .var do TargetNPC.
	set .v, getvariableofnpc(.var,"TargetNPC");
	
// Isso definirá a variável .var do TargetNPC como 1.
	set getvariableofnpc(.var,"TargetNPC"), 1;

Nota: embora os objetos de função possam ter variáveis,
getvariableofnpc não funcionará neles.

---------------------------------------

*goto <label>;

Esse comando fará com que o script salte para uma label, 
comumente usado em conjunto com outro comando, como "if", 
mas frequentemente usado sozinho.

	...
	goto Label;
	mes "Isso não será visto";
Label:
	mes "Isso será visto";

Nota de FlavioJS: os goto's são "maus" e devem ser evitados se possível (ò_ó)

---------------------------------------

*menu "<option_text>",<target_label>{,"<option_text>",<target_label>,...};

Este comando criará um menu selecionável para o jogador. Apenas um
menu pode estar na tela ao mesmo tempo.

Dependendo do que o jogador escolher no menu, a execução do script continuará na label correspondente. (são pares de label de string, não string da label)

As opções podem ser agrupadas, separadas pelo caractere ':'.

	menu "A:B",L_Wrong,"C",L_Right;

Também define uma variável especial de personagem temporário @menu, que contém o
número de opções que o jogador escolheu. (A numeração de opções começa em 1.)
Esse número é consistente com opções vazias e opções agrupadas.

       menu "A::B",L_Wrong,"",L_Impossible,"C",L_Right;
    L_Wrong:
		// Se eles clicarem em "A" ou "B", eles acabarão aqui
		// @menu == 1 se "A"
		// @menu == 2 nunca acontecerá porque a opção está vazia
		// @menu == 3 se "B"
	L_Impossible:
		// Opções vazias não são exibidas e, portanto, não podem ser selecionadas
		// esta label nunca será alcançada a partir do comando de menu
    L_Right:
        // Se eles clicarem em "C" eles vão acabar aqui
	    // @menu == 5

Se a label for '-', a execução do script continuará logo após o comando de menu,
se essa opção for selecionada, isso poderá ser usado para economizar tempo 
e otimizar os grandes scripts.

        menu "A::B:",-,"C",L_Right;
        // Se eles clicarem em "A" ou "B", eles acabarão aqui
		// @menu == 1 se "A"
		// @menu == 3 se "B"
    L_Right:
         // Se eles clicarem em "C" eles vão acabar aqui
		// @menu == 5

Ambos os exemplos irão executar exatamente a mesma tarefa.

Se você der uma string vazia como um item de menu, o item não será exibido. este
pode ser efetivamente usado para criar scripts de menus dinâmicos usando uma string vazia para
entradas que devem estar indisponíveis naquele momento.

Você pode fazê-lo usando array, mas observe com atenção - esse truque não é uma grande magia, 
mas pelo menos uma mágica menor. Você não pode esperar duplicá-lo facilmente até entender como funciona.

Crie uma array temporária de strings para conter seus itens de menu e preencha-a com as strings que
devem entrar no menu nessa execução, certificando-se de não deixar nenhuma lacuna. 
Normalmente, você faz isso com um loop e um contador extra, como este:

	setarray @possiblemenuitems$[0],<list of potential menu items>;
	@j = 0; // Esse é o contador de linhas do menu.
	
	// Nós percorremos a lista de possíveis itens do menu.
	// @i é o nosso contador de loops.
	for( @i = 0; @i < getarraysize(@possiblemenuitems$); @i++ )
	{
		// Aquela 'condition' é qualquer condição que determina se
		// um número de item do menu @i realmente entra no menu ou não.
		
		if (<condition>)
		{
			// Gravamos a opção na lista de opções realmente disponíveis.
			
			@menulist$[@j] = @possiblemenuitems$[@i];
			
			// Acabamos de copiar a string, precisamos do número para mais tarde
			// embora, então nós gravamos também.
			
			@menureference[@j] = @i;
			
			// Como acabamos de adicionar um item do menu à lista, incrementamos
			// o contador de linhas do menu.
			
			@j++;
		}
		
		//  Vamos para o próximo item do menu possível.
	}

Isso criará uma array @menulist$ que contém o texto de todos os itens que devem 
realmente entrar no menu com base na sua condição, e uma array @menureference, 
que contém números na lista de possíveis itens do menu. (Lembre-se, as arrays
começam com 0.) Há menos deles do que os possíveis menu de itens que você definiu, mas o comando
de menu pode manipular as linhas vazias - somente se elas forem as últimas da lista, 
e se for feito dessa forma, agora vem um truque sujo:

	// X é qualquer um dos itens de menu que você espera manipular.
	menu @menulist$[0],-,@menulist$[1],-,....@menulist$[<X>],-;

Isso chama um menu de todos os seus itens. Como você não copiou alguns dos itens de 
menu possíveis na lista, o final está vazio e, portanto, nenhum item de menu será exibido 
após o final. Mas esta chamada de menu não salta para qualquer lugar, apenas continua a 
execução logo após o comando do menu. (E é uma coisa boa que isso não acontece, porque 
você só pode definir explicitamente as labels para onde ir e como você sabe quais definir 
se você não sabe de antemão quais opções vão acabar no seu menu?) Mas Como você descobre 
qual opção o usuário escolheu? Digite o @menu.

@menu contém o número de opções que o usuário selecionou da lista, 
começando com 1 para a primeira opção. Você sabe agora qual opção o usuário 
escolheu e qual número na sua lista real de possíveis itens de menu para os quais ele traduziu:


    mes "Você selecionou "+@possiblemenuitems$[@menureference[@menu-1]]+"!";

@menu é o número de opções escolhidas pelo usuário.
@menu-1 é o índice da array para a lista de itens de menu realmente usados ​​que fizemos.
@menureference[@menu-1] é o número do item na array de possíveis itens 
de menu que salvamos apenas para essa finalidade.

E @possiblemenuitems$[@menureference[@menu-1]] é a string que usamos para
exibir a linha de menu escolhida pelo usuário. (Sim, é trabalhoso, mas funciona.)

Você pode configurar várias instruções 'if (@menureference [@ menu-1] == X) goto Y' 
para rotear sua execução com base na linha selecionada e ainda gerar um menu diferente 
a cada vez, o que é útil quando você quiser para, por exemplo, fazer com que os usuários 
selecionem itens em qualquer ordem específica antes de continuar, ou fazer um menu 
embaralhado aleatoriamente.

O código Kafra empacotado com a distribuição padrão usa uma array baseada em
técnica de menu para listas de teleporte, mas é muito mais simples e não usa @menu,
provavelmente, já que isso não foi documentado em nenhum lugar.

Veja também 'select', o que provavelmente é melhor neste caso particular. Ao invés de
menu, você poderia usar 'select' assim:

    @dummy = select(@menulist$[0],@menulist$[1],....@menulist$[<X>]);
    
Para os propósitos da técnica descrita acima, estas duas afirmações são
perfeitamente equivalente.

---------------------------------------

*select("<option>"{,"<option>",...})
*prompt("<option>"{,"<option>",...})

Esta função é um substituto útil para o 'menu' para alguns casos específicos 
em que você não quer uma estrutura complexa das labels - como, por exemplo, 
fazer perguntas sim-não simples. Ele retornará o número da opção de menu 
escolhida, começando com 1. Como 'menu', ele também irá configurar a 
variável @menu para conter a opção escolhida pelo usuário.

    if (select("Sim:Não")==1) mes "Você disse sim, eu sei.";

E como "menu", a opção selecionada é consistente com as opções agrupadas
e opções vazias.

'prompt' funciona quase da mesma forma que select, exceto que quando um 
personagem clica no botão "Cancel", esta função retornará 255 em seu lugar.
---------------------------------------

*input(<variable>{,<min>{,<max>}})

Este comando fará uma box pop up aparecer no cliente conectado para o 
jogador, para permitir a inserção de um número ou uma string. 
Isso tem muitos usos, um exemplo seria um jogo de adivinhação, também 
fazendo uso da função 'rand':

	mes "[Woman]";
	mes "Tente adivinhar o número em que estou pensando.";
	mes "O número será entre 1 e 10.";
	next;
	.@number = rand(1,10);
	input .@guess;
	if (.@guess == .@number) {
		mes "[Woman]";
		mes "Bem feito, esse era o número que eu estava pensando!";
		close;
	} else {
		mes "[Woman]";
		mes "Desculpe, esse não era o número que eu estava pensando.";
		close;
	}

Se você der ao comando de entrada uma variável de string para colocar a 
entrada, ela permitirá que o jogador insira texto. Caso contrário, 
apenas números serão permitidos.

	mes "[Woman]";
	mes "Por favor, diga OLÁ";
	next;
	input .@var$;
	if (.@var$ == "OLÁ") {
		mes "[Woman]";
		mes "Muito bem, você digitou corretamente.";
		close;
	} else {
		mes "[Woman]";
		mes "Desculpe, você digitou errado.";
		close;
	}

Normalmente você não pode inserir um número negativo com este comando. 
Isso é feito para evitar explorações em scripts mal escritos, o que 
permitiria que as pessoas, por exemplo, colocassem quantidades negativas
de Zeny em um script de banco e recebessem gratuitamente o Zeny.

Desde o trunk r12192, o comando tem dois argumentos opcionais e um valor de retorno. 
O valor padrão de 'min' e 'max' pode ser definido com 'input_min_value' 
e 'input_max_value' em script_athena.conf. Para entradas numéricas, o valor 
é limitado ao intervalo [min, max]. Retorna 1 se o valor for maior que 'max', -1 
se menor que 'min' e 0 caso contrário.Para entradas de string ele retorna 1 se a 
string for maior que 'max', -1 é menor que 'min' e 0.

---------------------------------------

*callfunc "<function>"{,<argument>,...<argument>};
*callfunc("<function>"{,<argument>,...<argument>})

Este comando permite chamar uma função NPC. Uma função NPC pode ser 
chamada de qualquer script em qualquer map server. Usando o 
comando 'return', ele retornará ao local que o chamou.

	place,50,50,6%TAB%script%TAB%Woman%TAB%115,{
		mes "[Woman]"
		mes "Vamos ver se você ganha ...";
		callfunc "funcNPC";
		mes "Muito bem, você ganhou!";
		close;
	}
	function%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(2);
		if (.@win == 0) return;
		mes "Desculpe, você perdeu.";
		close;
	}

Você pode passar argumentos para a sua função - valores dizendo exatamente o que fazer - 
que estarão disponíveis com getarg () (veja 'getarg') Observe que retornar não é obrigatório, 
você pode finalizar a execução ali mesmo.

Se você quiser retornar um valor real de dentro da sua função NPC, é melhor escrevê-lo 
na forma defunção, que também funcionará e tornará o script geralmente mais limpo:

	place,50,50,6%TAB%script%TAB%Man%TAB%115,{
		mes "[Man]"
		mes "Me dê um número!";
		next;
		input @number;
		if (callfunc("OddFunc",@number)) mes "Isso é ímpar!";
		close;
	}
	function%TAB%script%TAB%OddFunc%TAB%{
		if (getarg(0)%2==0) return 0;// Isso é par
		return 1;// Isso é ímpar
	}

Como alternativa, a partir da revisão do rAthena 15979 e 15981, as funções definidas 
pelo usuário podem ser chamadas diretamente sem o uso do comando de script 'callfunc'.

	function<tab>script<tab>SayHello<tab>{
		mes "Olá " + getarg(0);
		return 0;
	}

	place,50,50,6<tab>script<tab>Man<tab>115,{
		mes "[Man]";
		SayHello strcharinfo(0);
		close;
	}

Nota:

 !! Uma função definida pelo usuário deve ser declarada /antes/ que um script tente
 !! chamá-la. Ou seja, qualquer função deve ser colocada acima de scripts ou NPCs
 !! (ou carregado em um arquivo separado primeiro) antes de tentar chamá-los diretamente.

---------------------------------------

*callsub <label>{,<argument>,...<argument>};
*callsub(<label>{,<argument>,...<argument>})

Esse comando irá para uma label especificada dentro do script atual (NÃO use aspas 
ao redor dele) como se fosse uma chamada 'callfunc', e passará os argumentos 
dados, se houver, que podem ser recuperados com 'getarg'. Quando terminar, 
você deve usar o comando 'return' para voltar ao ponto de onde essa label
foi chamada. Isso é usado quando há uma coisa específica que o script fará 
repetidas vezes, isso permite que você use o mesmo código quantas vezes quiser, 
para economizar espaço e tempo, sem criar objetos NPC extras que são necessários 
com 'callfunc'. Uma label não é chamada desta maneira a partir de outro script.

Exemplo 1: callub para verificação (se os checks forem aprovados, retorne ao script)
	callsub S_CheckFull, "guild_vs2",50;
	switch( rand(4) ) {
		case 0:	warp "guild_vs2",9,50;	end;
		case 1:	warp "guild_vs2",49,90;	end;
		case 2:	warp "guild_vs2",90,50;	end;
		case 3:	warp "guild_vs2",49,9;	end;
	}

...

S_CheckFull:
	if (getmapusers(getarg(0)) >= getarg(1)) {
		mes "Me desculpe, esta arena está cheia. Por favor, tente novamente mais tarde.";
		close;
	}
	return;

Exemplo 2: callub usado repetidamente, com argumentos diferentes
// observe como a check/delete do Zeny é reutilizada, em vez de copiar e colar para cada warp
	switch(select("Abyss Lake:Amatsu Dungeon:Anthell:Ayothaya Dungeon:Beacon Island, Pharos") {
		case 1:	callsub S_DunWarp,"hu_fild05",192,207;
		case 2:	callsub S_DunWarp,"ama_in02",119,181;
		case 3:	callsub S_DunWarp,"moc_fild20",164,145;
		case 4:	callsub S_DunWarp,"ayo_fild02",279,150;
		case 5:	callsub S_DunWarp,"cmd_fild07",132,125;
		// etc
	}

...

S_DunWarp:
// getarg(0) = "nome do mapa"
// getarg(1) = x
// getarg(2) = y
	if (Zeny >= 100) {
		Zeny -= 100;
		warp getarg(0),getarg(1),getarg(2);
	} else {
		mes "Teleporte para o calabouço custa 100 Zeny.";
	}
	close;

---------------------------------------

*getarg(<index>{,<default_value>})

Esta função é usada quando você usa os comandos 'callub' ou 'callfunc'. 
Na chamada, você pode especificar variáveis que tornem a chamada 
diferente de outra. Esta função retornará um argumento com o qual
a função ou sub-rotina foi chamada e é a maneira normal de obtê-los. 
Essa é outra coisa que pode permitir que você use o mesmo código mais de uma vez.

A numeração de argumentos começa com 0, ou seja, o primeiro argumento que você deu é o número 0.
Se nenhum argumento foi dado, um zero é retornado.

	place,50,50,6%TAB%script%TAB%Woman1%TAB%115,{
		mes "[Woman]";
		mes "Vamos ver se você ganha...";
		callfunc "funcNPC",2;
		mes "Bem feito, você ganhou!";
		close;
	}

	place,52,50,6%TAB%script%TAB%Woman2%TAB%115,{
		mes "[Woman]";
		mes "Vamos ver se você ganha...";
		callfunc "funcNPC",5;
		mes "Muito bem, você ganhou!";
		close;
	}

	function%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(getarg(0));
		if (.@win == 0) return;
		mes "Desculpe, você perdeu.";
		close;
	|

O objeto NPC "woman1" chama o funcNPC. O argumento que ele dá nesta chamada 
é declarado como 2, então quando o número aleatório é gerado pela função 
'rand', ele só pode ser 0 ou 1. Considerando que "woman2" fornece 5 como 
o argumento número 0 ao chamar a função, Assim, o número aleatório pode ser 
0, 1, 2, 3 ou 4, o que torna menos provável que "woman2" diga que o jogador venceu.

Você pode passar vários argumentos em uma callfunc:

	callfunc "funcNPC",5,4,3;

getarg(0) seria 5, getarg(1) seria 4 e getarg(2) seria 3.

'getarg' tem um argumento opcional desde o trunk r10773 e estável r10958.Se o 
argumento de destino existir, ele será retornado.Caso contrário, 
se <default_value> estiver presente, ele será retornado, se não, o 
script terminar imediatamente.

No exemplo anterior, getarg(2, -1) seria 3 e getarg(3, -1) seria -1.

---------------------------------------

*getargcount()

Esta função é usada quando você usa os comandos 'callub' ou 'callfunc'. 
Na call você pode especificar argumentos. Esta função retornará 
o número de argumentos fornecidos.

Exemplo:
	callfunc "funcNPC",5,4,3;
	...
	function%TAB%script%TAB%funcNPC%TAB%{
		.@count = getargcount(); // 3
		...
	}

---------------------------------------

*return {<value>};

Este comando faz com que a execução do script deixe a função anteriormente 
chamada com callfunc ou script com callub e retorne ao local, onde o calloriginated está. 
Opcionalmente, um valor de retorno pode ser fornecido quando a chamada 
foi feita usando a forma de função.

Usando este comando fora de funções ou scripts referenciados pelo callub irá 
resultar em erro e término do script.

	callfunc "<your function>";// quando nada é retornado
	set <variable>,callfunc("<your function>");// quando um valor está sendo retornado

---------------------------------------

*function <function name>;
*<function name>{(<argument>,...<argument>)};
*function <function name> {
<code>
}

Isso funciona como callfunc e é usado para scripts mais limpos e rápidos. 
A função deve ser definida e usada em um script e funciona como 
uma label com argumentos. Observe que o nome pode conter apenas 
caracteres alfanuméricos e sublinhados.

Uso:

     1. Declare a função.
	function <function name>;
     2. Chame a função em qualquer lugar dentro do script.
        Também pode retornar um valor quando usado com parênteses.
	<function name>;
     3. Defina a função dentro do script.
	<function name> {<code>}

Exemplo:

prontera,154,189,4	script	Item Seller	767,{
	/* Declaração da Função*/
	function SF_Selling;

	if (Zeny > 50) {
		mes "Bem-vindo!";
		/* Chama Função */
		SF_Selling;
	}
	else mes "Você precisa de 50z, desculpe!";
	close;

	/* Function definition */
	function SF_Selling {
		mes "Você gostaria de comprar um phracon por 50z?";
		next;
		if(select("Sim","Não, obrigado") == 1) {
			Zeny -= Zeny;
			getitem 1010,1;
			mes "Obrigado!";
		}
		return;
	}
}

Exemplo com parâmetros e valor de retorno:

prontera,150,150,0	script	TestNPC	123,{
	/* Declaração de Função */
	function MyAdd;

	mes "Insira dois números.";
	next;
	input .@a;
	input .@b;
	/* Chama função */
	mes .@a+" + "+.@b+" = "+MyAdd(.@a,.@b);
	close;

	/* Definição da Função */
	function MyAdd {
		return getarg(0)+getarg(1);
	}
}


---------------------------------------

*is_function("<function name>")

Este comando verifica se existe uma função.
Retorna 1 se a função for encontrada ou 0 se não existir.

Exemplo:

	function	script	try	{
		dothat;
	}

	-	script	test	-1,{
		.@try = is_function("try"); // 1
		.@not = is_function("not"); // 0
	}

---------------------------------------

*if (<condition>) <statement>;

Este é o comando básico da instrução condicional e apenas o único disponível 
nesta linguagem de script.

A condição pode ser qualquer expressão. Todas as expressões que resultarem 
em um valor diferente de zero serão consideradas True, incluindo 
valores negativos. Todas as expressões que resultam em um zero são falsas (false).

Se a expressão resultar em True, a instrução será executada. Se não for
verdade, nada acontece e passamos para a próxima linha do script.

    if (1)  mes "Isso sempre será printado.";
    if (0)  mes "E isso nunca será printado";
    if (5)  mes "Isso também será sempre printado";
    if (-1) mes "Engraçado como isso é, isso também vai ser printado.";

Para obter mais informações sobre operadores condicionais, consulte a seção operadores acima. 
Qualquer coisa que seja retornada por uma função pode ser usada em uma verificação de 
condição sem se preocupar em armazená-la em uma variável específica:

    if (strcharinfo(0)=="Daniel Jackson") mes "É verdade, você é Daniel!";

Mais exemplos de uso do comando 'if' no mundo real:

Exemplo 1:

	.@answer = 1;
	input .@input;
	if (.@input == .@answer)
		close;
	mes "Desculpe, sua resposta está incorreta.";
        close;

Exemplo 2:
    
	.@answer = 1;
	input .@input;
	if (.@input != .@answer)
		mes "Desculpe, sua resposta está incorreta.";
	close;

Observe que os exemplos 1 e 2 têm o mesmo efeito.

Exemplo 3:

	@count++;
	mes "[Forgetful Man]";
	if (@count == 1) mes "Esta é a primeira vez que você falou comigo.";
	if (@count == 2) mes "Esta é a segunda vez que você fala comigo.";
	if (@count == 3) mes "Esta é a terceira vez que você fala comigo.";
	if (@count == 4) {
		mes "Esta é a quarta vez que você falou comigo";
		mes "Eu acho que estou ficando com amnésia, eu esqueci de você...";
		@count = 0;
	}
	close;

Exemplo 4:

	mes "[Quest Person]";
	if (countitem(512) < 1) {  // 512 é o ID do item para a Maçã, encontrado em item_db
		mes "Você pode por favor me trazer uma maçã?";
		close;
	}
        mes "Oh, você trouxe uma maçã!";
	mes "Eu não queria ela, só queria ver uma.";
	close;

Exemplo 5:

	mes "[Person Checker]";
	if ($@name$ == "") {  // varíavel global ainda não definida
		mes "Por favor me diga o nome de alguém";
		next;
		input $@name$;
		$@name2$ = strcharinfo(0);
		mes "[Person Checker]";
		mes "Obrigado.";
		close;
	}
	if ($@name$ == strcharinfo(0)) {  // player name matches $@name$
		mes "Você é a pessoa que " +$@name2$+ " havia mencionado.";
		mes "Prazer em conhecê-lo!";

		// redefinir as variáveis globais
		$@name$ = "";
		$@name2$ = "";

		close;
	}
	mes "Você não é a pessoa que " +$@name2$+ " havia mencionado.";
	close;

Veja 'strcharinfo' para uma explicação sobre o que esta função faz.

Exemplo 6: Usando condições complexas.

	mes "[Multiple Checks]";
	if ( (@queststarted == 1) && (countitem(512) >= 5) ) {
		mes "Muito bem, você começou a missão e me trouxe 5 maçãs.";
		@queststarted = 0;
		delitem 512,5;
		close;
	}
	mes"Por favor, traga-me 5 maçãs.";
	@queststarted = 1;
	close;

O mecanismo de script também suporta instruções 'if' aninhadas:

	if (<condition>)
		façaisso;
	else
		façaaquilo;

Se a condição não for atendida, ela fará a ação seguindo o 'else'.
Também podemos agrupar várias ações dependendo de uma condição:

	if (<condition>) {
		façaisso1;
		façaisso2;
	} else {
		façaaquilo1;
		façaaquilo2;
		façaaquilo3;
	}

Lembre-se que, se você planeja executar várias ações quando a condição é falsa,
e se esquece de usar as chaves ({}), a segunda ação será executada independentemente 
da saída da condição, a menos que você pare a execução de o script se a condição 
for verdadeira (ou seja, no primeiro agrupamento usando um return;, end; ou um close; )

Além disso, você pode ter várias condições aninhadas ou encadeadas, e não se 
preocupe com limites quanto a quantos aninhados você pode ter. ;)

	if (<condition 1>)
		façaisso;
	else if (<condition 2>) {
		façaaquilo;
		end;
	} else
		façaisso;

---------------------------------------

*jump_zero (<condition>),<label>;

Este comando funciona como uma combinação 'if' + 'goto' de uma só vez. 
(Veja 'if'). Se a condição for falsa (igual a zero), este comando irá pular 
imediatamente para a label especificada, como em 'goto'. Embora 'if' seja 
mais geralmente útil, para alguns casos isso poderia ser uma otimização.

A principal razão para este comando é que outras instruções de controle, 
como 'switch', 'for' ou 'while', são desmontadas em expressões simples 
juntamente com este comando quando um script é analisado.

---------------------------------------

*switch (expression);

A instrução switch é semelhante a uma série de instruções if na mesma expressão.
Em muitas ocasiões, você pode querer comparar a mesma variável (ou expressão)
com muitos valores diferentes, e executar um pedaço diferente de código, dependendo
em qual valor é igual a. É exatamente para isso que serve a instrução do switch.

É importante entender como a instrução switch é executada para
para evitar erros. A instrução switch executa linha por linha (na verdade, declaração por instrução).
No começo, nenhum código é executado. Somente quando uma declaração de caso é encontrada
com um valor que corresponda ao valor da expressão switch que a(s) 
declaração(ões) será(ão) executada(a). O analisador continua a executar as instruções até o final
do bloco switch, ou a primeira vez que ele vê uma instrução break. Se você não
escrever uma instrução break no final da lista de instruções de um caso, o analisador
continuará executando as instruções do caso seguinte(fall-through).

Exemplo 1:
	
	switch(select("Yes:No")) {
		case 1:
			mes "Você disse sim!";
			break;
		case 2:
			mes "Aww, porque?";
			break;
	}
	close;

O exemplo acima funcionaria como um menu e iria para o primeiro caso se
o usuário seleciona a opção, caso contrário, iria para o segundo.

Exemplo 2:
	
	switch(getgroupid()) {
		case 1:
			mes "Uau, você é demais!";
			break;
		case 2:
			mes "Uma ajudinha!";
			break;
		case 3:
			mes "10001010010011";
			break;
		case 4:
			mes "Sim, milord?";
			break;
		default:
			mes "Olá!";
			break;		
	}
	

O exemplo acima imprimiria uma mensagem dependendo do groupid do jogador.
Se não houver declaração declarada para o correspondente groupid, o script
usaria a instrução 'padrão' que se aplica ao restante dos valores possíveis,
semelhante a 'else' na instrução if-else.

---------------------------------------

*while (<condition>) <statement>;

Esta é provavelmente a estrutura de loop mais simples e mais freqüentemente usada. A instrução 'while'
pode ser interpretada como "while <condition> é true, execute <instrução>".
É um loop de pré-teste, ou seja, a expressão condicional é testada antes de qualquer um dos
declarações no corpo do loop são executadas. Se a condição for avaliada como
false, a(s) declaração(ões) no corpo do loop é (ou não) é(são) executada(s). Se 
a condição é avaliada como verdadeira, a(s) instrução(ões) é(são) executada(s) e, 
em seguida, controla as transferências de volta à expressão condicional, que é 
reavaliada e o ciclo continua.

Várias instruções podem ser agrupadas com {}, chaves, assim como com a instrução 'if'.

Exemplo 1:
	while (switch(select("Sim:Não") == 2 ))
		mes "Você escolheu não.";
	close;

Exemplo 2: múltiplas declarações
	while (switch(select("Sim:Não") == 2 )) {
		mes "Por que você escolheu não?";
		mes "Você deveria ter escolhido sim!";
	}
	close;

Exemplo 3: counter-controlled loop
	.@i = 1;
	while (.@i <= 5) {
		mes "Esta linha será printada 5 vezes.";
		.@i += 1;
	}
	close;

Exemplo 4: sentinel-controlled loop
	mes "Digite 0 para parar";
	input .@num;
	while (.@num != 0) {
		mes "Você entrou " + .@num;
		input .@num;
	}
	close;

---------------------------------------

*for (<variable initialization>; <condition>; <variable update>) <statement>;

Outra estrutura em loop do pré-teste é a instrução 'for'. Considera-se um
forma especializada da declaração "while", e geralmente está associada a
loops controlados. Aqui estão os passos da instrução 'for': a instrução de inicializar
é executada primeiro e apenas uma vez. O teste de condição é executado.
Quando a condição é avaliada como falsa, o restante da instrução "for" é ignorado.
Quando a condição é avaliada como verdadeira, o corpo do loop é executado, então a
instrução de atualização é executada (isso geralmente envolve o incremento de uma variável).
Então a condição é reavaliada e o ciclo continua.

Exemplo 1:
	for( .@i = 1; .@i <= 5; .@i++ )
		mes "Esta linha será printada 5 vezes.";
Exemplo 2:
	mes "Isto irá imprimir os números 1 - 5.";
	for( .@i = 1; .@i <= 5; .@i++ )
		mes "Número: " + .@i;

---------------------------------------

*do { <statement>; } while (<condition>);

O 'do ... while' é a única estrutura de loop de pós-teste disponível nesta linguagem-script.
Com um pós-teste, as instruções são executadas uma vez antes da condição
testada. Quando a condição é verdadeira, a(s) instrução(ões) é(são) repetida(s). Quando a
condição é falsa, o controle é transferido para a declaração após a expressão de laço
'do ... while'.

Exemplo 1: sentinel-controlled loop
	mes "Este menu continuará aparecendo até você selecionar Cancelar";
	do {
		.@menu = select("Um:Dois:Três:Cancelar");
	} while (.@menu != 4);

Exemplo 2: counter-controlled loop
	mes "Isso será contado de 10 para 1.";
	.@i = 10;
	do {
		mes .@i;
		.@i -= 1;
	} while (.@i > 0);

---------------------------------------

*freeloop({<toggle>})

O Toggle, este é habilitado (1) permite que a instância de script contorne a proteção do loop infinito,
permitindo que o seu script faça um loop tanto quanto for necessário. Desativando (0)
avisará se um loop infinito for detectado.

O comando retornará o estado do freeloop para o script anexado, mesmo que nenhum
argumento for fornecido.

Exemplo:
	freeloop(1); // permitir que o script faça um loop livremente

	// tenha cuidado com o que você faz aqui
	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		façaisso;
		// script vai parar por 1ms quando detectar um loop infinito
		// deixe o rAthena fazer o que precisa fazer (socket, timer, process, etc.)
	}

	freeloop(0); // desabilitar o freeloop

	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		façaisso;
		// lança um erro de loop infinito
	}

---------------------------------------

*setarray <array name>[<first value>],<value>{,<value>...<value>};

Este comando permitirá que você preencha rapidamente um array de uma só vez. Verifica
scripts das Kafras na distribuição para ver isso usado muito.

    setarray @array[0], 100, 200, 300, 400, 500, 600;

Primeiro valor é o índice do primeiro elemento da matriz para alterar. Por
exemplo:

    setarray @array[0],200,200,200;
    setarray @array[1],300,150;
    
Produdirá:

 @array[0]=200
 @array[1]=300
 @array[2]=150

---------------------------------------

*cleararray <array name>[<first value to alter>],<value>,<number of values to set>;

Este comando irá alterar vários valores de matriz ao mesmo tempo para o mesmo valor.

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    // Isso fará com que todos os 6 valores sejam 0
    cleararray @array[0],0,6;
    // Isso fará com que o elemento 0 da array seja alterado para 245
    cleararray @array[0],245,1;
    // Isso fará com que os elementos 1 e 2 mudem para 345
    cleararray @array[1],345,2;

Veja 'setarray'.

---------------------------------------

*copyarray <destination array>[<first value>],<source array>[<first value>],<amount of data to copy>;

Este comando permite que você embaralhe rapidamente muitos dados entre arrays, que estão em
alguns casos inestimáveis.

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    //Então fizemos @array []
    copyarray @array2[0],@array[2],2;
    
    // Agora, @array2[0] será igual a @array[2] (300) e
    // @array2[1] será igual a @array[3].

Então, usando os exemplos acima:
 @array[0] = 100
 @array[1] = 200
 @array[2] = 300
 @array[3] = 400
 @array[4] = 500
 @array[5] = 600
 
Nova array:
 @array2[0] = 300
 @array2[1] = 400
 @array2[2] = 0
 @array2[3] = 0

Observe que @array [4] e @array [5] não serão copiados para o segundo array, e ele retornará um
0.

---------------------------------------

*deletearray <array name>[<first value>],<how much to delete>;

Este comando excluirá um número especificado de elementos da array totalmente de uma
array, deslocando todos os elementos além deste em direção ao início.

    // Isso excluirá o elemento 0 da array e moverá todos os outros elementos da array
    // um lugar acima.
    deletearray @array[0],1

   // Isso excluiria elementos da array numerados 1, 2 e 3, deixando o elemento 0 em seu
   // lugar, e mover os outros elementos acima, então não há lacunas.

    deletearray @array[1],3

---------------------------------------

======================================
|2.- Information-retrieving commands.|
======================================
---------------------------------------

*strcharinfo(<type>)

This function will return either the name, party name or guild name for the 
invoking character. Whatever it returns is determined by type.

 0 - Character's name.
 1 - The name of the party they're in if any.
 2 - The name of the guild they're in if any.
 3 - The name of the map the character is in.
 
If a character is not a member of any party or guild, an empty string will be 
returned when requesting that information.

---------------------------------------

*strnpcinfo(<type>)

This function will return the various parts of the name of the calling NPC.
Whatever it returns is determined by type.

 0 - The NPC's display name (visible#hidden)
 1 - The visible part of the NPC's display name
 2 - The hidden part of the NPC's display name
 3 - The NPC's unique name (::name)
 4 - The name of the map the NPC is in.

---------------------------------------

*getarraysize(<array name>)

This function returns the number of values that are contained inside the 
specified array. Notice that zeros and empty strings at the end of this array 
are not counted towards this number.

For example:

    setarray @array[0], 100, 200, 300, 400, 500, 600;
    set @arraysize,getarraysize(@array);

This will make @arraysize == 6. But if you try this:

    setarray @array[0], 100, 200, 300, 400, 500, 600, 0;
    set @arraysize,getarraysize(@array);
    
@arraysize will still equal 6, even though you've set 7 values.    

---------------------------------------

*getelementofarray(<array name>,<index>)

This command retrieves the value of the element of given array at given index.
This is equivalent to using:

    <array name>[<index>]

The reason for this is, that this short form is internally converted into a call
to getelementofarray, when the script is loaded.

Also useful when passing arrays to functions or accessing another npc's arrays: 
    getelementofarray(getarg(0),<index>)
    getelementofarray(getvariableofnpc(.var, "testNPC"),<index>)

---------------------------------------

*readparam(<parameter number>{,"<character name>"})

This function will return the specified stat of the invoking character, or, if a
character name is specified, of that player. The stat can either be a number or
paramter name, defined in 'db/const.txt'.

Some example parameters:

StatusPoint, BaseLevel, SkillPoint, Class, Upper, Zeny, Sex, Weight, MaxWeight,
JobLevel, BaseExp, JobExp, NextBaseExp, NextJobExp, Hp, MaxHp, Sp, MaxSp,
BaseJob, Karma, Manner, bVit, bDex, bAgi, bStr, bInt, bLuk

All of these also behave as variables, but don't expect to be able to just 'set' 
them - some will not work for various internal reasons.

Example 1:

    // Returns how many status points you haven't spent yet.
    mes "Unused status points: "+readparam(9);

Using this particular information as a function call is not required. Typing this
will return the same result:

    mes "Unused status points: "+StatusPoint;

Example 2:

You can also use this command to get stat values.

    if (readparam(bVit) > 77)
        mes "Only people with over 77 Vit are reading this!";

---------------------------------------

*getcharid(<type>{,"<character name>"})

This function will return a unique ID number of the invoking character, or, if a 
character name is specified, of that player.

Type is the kind of associated ID number required:

 0 - Character ID number.
 1 - Party ID number.
 2 - Guild ID number.
 3 - Account ID number.
 4 - Battle ground ID

For most purposes other than printing it, a number is better to have than a name 
(people do horrifying things to their character names).

If the character is not in a party or not in a guild, the function will return 0 
if guild or party number is requested. If a name is specified and the character 
is not found, 0 is returned.

If getcharid(0) returns a zero, the script got called not by a character and 
doesn't have an attached RID. Note that this will cause the map server to
print "player not attached!" error messages, so it is preferred to use
"playerattached" to check for the character attached to the script.

if (getcharid(2) == 0)
	mes "Only members of a guild are allowed here!";

---------------------------------------

*getnpcid(<type>{,"<npc name>"});

Retrieves IDs of the currently invoked NPC. If a unique npc name is
given, IDs of that NPC are retrieved instead. Type specifies what ID
to retrieve and can be one of the following:

    0 - Unit ID (GID)

If an invalid type is given or the NPC does not exist, 0 is returned.

---------------------------------------

*getchildid()
*getmotherid()
*getfatherid()

These functions return the character ID of the attached player's child,
mother, mother, or father, respectively. It returns 0 if no ID is found.

    if (getmotherid()) mes "Your mother's ID is: "+getmotherid();

---------------------------------------

*ispartneron()

This function returns 1 if the invoking character's marriage partner is 
currently online and 0 if they are not or if the character has no partner.

---------------------------------------

*getpartnerid()

This function returns the character ID of the invoking character's marriage 
partner, if any. If the invoking character is not married, it will return 0, 
which is a quick way to see if they are married:

    if (getpartnerid()) mes "I'm not going to be your girlfriend!";
    if (getpartnerid()) mes "You're married already!";

---------------------------------------

*getlook(<type>)

This function will return the number for the current character look value 
specified by type. See 'setlook' for valid look types.

This can be used to make a certain script behave differently for characters 
dressed in black. :)

---------------------------------------

*getsavepoint(<information type>)

This function will return information about the invoking character's save point. 
You can use it to let a character swap between several recorded save points. 
Available information types are:

 0 - Map name (a string)
 1 - X coordinate
 2 - Y coordinate

---------------------------------------
 
*getcharip({"<character name>"|<account id>|<char id>})

This function will return the IP address of the invoking character, or, if a player
is specified, of that character. A blank string is returned if no player is attached.
 
Examples:

// Outputs IP address of attached player.
	mes "Your IP: " + getcharip();

// Outputs IP address of character "Silver".
	mes "Silver's IP: " + getcharip("Silver");

---------------------------------------

*vip_status(<type>,{"<character name>"})

Returns various information about a player's VIP status.

Valid types:
 1 - VIP status. (1 if VIP, 0 if non-VIP)
 2 - VIP expire date. (timestamp string if VIP, 0 if non-VIP)
 3 - VIP time remaining. (timestamp string if VIP, 0 if non-VIP)

NOTE: This command is only available if the VIP System is enabled.

---------------------------------------

*vip_time <time>,{"<character name>"};

Changes a player's VIP time (in minutes). A positive value will increase time, and a
negative value will decrease time.

NOTE: This command is only available if the VIP System is enabled.

---------------------------------------

*addspiritball <count>,<duration>{,<char_id>};

Adds spirit ball to player for 'duration' in milisecond.

---------------------------------------

*delspiritball <count>{,<char_id>};

Deletes the spirit ball(s) from player.

---------------------------------------

*countspiritball {<char_id>};

Counts the spirit ball that player has.

---------------------------------------
\\
2,2 Item-related commands
\\
---------------------------------------

*getequipid(<equipment slot>)

This function returns the item ID of the item equipped in the equipment slot 
specified on the invoking character. If nothing is equipped there, it returns -1. 
Valid equipment slots are:

EQI_HEAD_TOP (1)          - Upper Headear
EQI_ARMOR (2)             - Armor (jackets, robes)
EQI_HAND_L (3)            - Left hand (weapons, shields)
EQI_HAND_R (4)            - Right hand (weapons)
EQI_GARMENT (5)           - Garment (mufflers, hoods, manteaus)
EQI_SHOES (6)             - Footgear (shoes, boots)
EQI_ACC_L (7)             - Accessory 1
EQI_ACC_R (8)             - Accessory 2
EQI_HEAD_MID (9)          - Middle Headgear (masks, glasses)
EQI_HEAD_LOW (10)         - Lower Headgear (beards, some masks)
EQI_COSTUME_HEAD_LOW (11) - Lower Costume Headgear
EQI_COSTUME_HEAD_MID (12) - Middle Costume Headgear
EQI_COSTUME_HEAD_TOP (13) - Upper Costume Headgear
EQI_COSTUME_GARMENT (14)  - Costume Garment
EQI_AMMO (15)    		  - Arrow/Ammunition
EQI_SHADOW_ARMOR (16)     - Shadow Armor
EQI_SHADOW_WEAPON (17)    - Shadow Weapon
EQI_SHADOW_SHIELD (18)    - Shadow Shield
EQI_SHADOW_SHOES (19)     - Shadow Shoes
EQI_SHADOW_ACC_R (20)     - Shadow Accessory 2
EQI_SHADOW_ACC_L (21)     - Shadow Accessory 1

Notice that a few items occupy several equipment slots, and if the character is 
wearing such an item, 'getequipid' will return its ID number for either slot.

Can be used to check if you have something equipped, or if you haven't got 
something equipped:

        if(getequipid(EQI_HEAD_TOP)==2234) goto L_WearingTiara;
        mes "Come back when you have a Tiara on";
        close;
    L_WearingTiara:
        mes "What a lovely Tiara you have on";
        close;

You can also use it to make sure people don't pass a point before removing an 
item totally from them. Let's say you don't want people to wear Legion Plate 
armor, but also don't want them to equip if after the check, you would do this:

        if ((getequipid(EQI_ARMOR) == 2341) || (getequipid(EQI_ARMOR) == 2342) goto L_EquipedLegionPlate;
    // the || is used as an or argument, there is 2341 and 2342 cause there are 
    // two different legion plate armors, one with a slot one without.
        if ((countitem(2341) > 0) || (countitem(2432) > 0) goto L_InventoryLegionPlate;
        mes "I will lets you pass";
        close2;
        warp "place",50,50;
        end;
    L_EquipedLegionPlate:
        mes "You are wearing some Legion Plate Armor, please drop that in your stash before continuing";
        close;
    L_InventoryLegionPlate:
        mes "You have some Legion Plate Armor in your inventory, please drop that in your stash before continuing";
        close;

---------------------------------------

*getequipuniqueid(<equipment slot>)

This function returns the unique ID (as a string) of the item equipped in the equipment slot 
specified on the invoking character. If nothing is equipped there, it returns an empty string.
See 'getequipid' for a full list of valid equipment slots.

---------------------------------------

*getequipname(<equipment slot>)

Returns the jname of the item equipped in the specified equipment slot on the
invoking character, or an empty string if nothing is equipped in that position.
Does the same thing as getitemname(getequipid()). Useful for an NPC to state
what your are wearing, or maybe saving as a string variable.
See 'getequipid' for a full list of valid equipment slots.

        if( getequipname(EQI_HEAD_TOP) != "" )
	        mes "So you are wearing a "+getequipname(EQI_HEAD_TOP)+" on your head";
	else
	        mes "You are not wearing any head gear";

---------------------------------------

*getitemname(<item id>)

Given the database ID number of an item, this function will return the text 
stored in the 'japanese name' field (which, in rAthena, stores an English name 
the players would normally see on screen.)

---------------------------------------

*getbrokenid(<number>)

This function will search the invoking character's inventory for any broken 
items, and will return their item ID numbers. Since the character may have 
several broken items, 1 given as an argument will return the first one found, 2 
will return the second one, etc. Will return 0 if no such item is found.

    // Let's see if they have anything broken:
        if (getbrokenid(1)==0) goto Skip;
    // They do, so let's print the name of the first broken item:
        mes "Oh, I see you have a broken "+getitemname(getbrokenid(1))+" here!";
    Skip:
        mes "You don't have anything broken, quit bothering me.";

---------------------------------------

*getequipisequiped(<equipment slot>)

This functions will return 1 if there is an equipment placed on the specified
equipment slot and 0 otherwise. For a list of equipment slots 
see 'getequipid'. Function originally used by the refining NPCs:

    if (getequipisequiped(EQI_HEAD_TOP)) goto L_equipped;
        mes "[Refiner]";
        mes "Do you want me to refine your dumb head?";
        close;
    L_equipped:
        mes "[Refiner]";
        mes "That's a fine hat you are wearing there...";
        close;

---------------------------------------

*getequipisenableref(<equipment slot>)

Will return 1 if the item equipped on the invoking character in the specified 
equipment slot is refinable, and 0 if it isn't. For a list of equipment slots 
see 'getequipid'.

        if (getequipisenableref(EQI_HEAD_TOP)) goto L_Refine;
        mes "[Refiner]";
        mes "I can't refine this hat!...";
        close;
    L_Refine:
        mes "[Refiner]";
        mes "Ok I can refine this";
        close;

---------------------------------------

*getequiprefinerycnt(<equipment slot>)

Returns the current number of pluses for the item in the specified equipment 
slot. For a list of equipment slots see 'getequipid'.

Can be used to check if you have reached a maximum refine value, default for 
this is +10:

        if(getequiprefinerycnt(EQI_HEAD_TOP) < 10) goto L_Refine_HeadGear;
        mes "Sorry, it's not possible to refine hats better than +10";
        close;
    L_Refine_HeadGear:
        mes "I will now upgrade your "+getequipname(EQI_HEAD_TOP);

---------------------------------------

*getequipweaponlv(<equipment slot>)

This function returns the weapon level for the weapon equipped in the specified 
equipment slot on the invoking character. For a list of equipment slots see 
'getequipid'.

Only EQI_HAND_L and EQI_HAND_R normally make sense, since only weapons have
a weapon level. You can, however, probably, use this field for other equippable
custom items as a flag or something.

If no item is equipped in this slot, or if it doesn't have a weapon level 
according to the database, 0 will be returned.

Examples:

// Right hand can only contain a weapon.
    switch (getequipweaponlv(EQI_HAND_R)) {
      case 1: mes "You are holding a lvl 1 weapon."; break;
      case 2: mes "You are holding a lvl 2 weapon."; break;
      case 3: mes "You are holding a lvl 3 weapon."; break;
      case 4: mes "You are holding a lvl 4 weapon."; break;
      case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design..."; break;
      default: mes "Seems you don't have a weapon on."; break;
    }

// Left hand can hold either a weapon or shield.
    if (getequipid(EQI_HAND_R) == 0) {
        mes "Seems you have nothing equipped here.";
        close;
    }
    switch (getequipweaponlv(EQI_HAND_L)) {
      case 0: mes "You are holding a shield, so it doesn't have a level."; break;
      case 1: mes "You are holding a lvl 1 weapon."; break;
      case 2: mes "You are holding a lvl 2 weapon."; break;
      case 3: mes "You are holding a lvl 3 weapon."; break;
      case 4: mes "You are holding a lvl 4 weapon."; break;
      case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design..."; break;
    }

---------------------------------------

*getequippercentrefinery(<equipment slot>)

This function calculates and returns the percent value chance to successfully 
refine the item found in the specified equipment slot of the invoking character 
by +1. There is no actual formula, the success rate for a given weapon level of
a certain refine level is found in the db/refine_db.txt file. For a list of
equipment slots see 'getequipid'.

These values can be displayed for the player to see, or used to calculate the 
random change of a refine succeeding or failing and then going through with it 
(which is what the official NPC refinery scripts use it for)

// This will find a random number from 0 - 99 and if that is equal to or more 
// than the value recovered by this command it will go to L_Fail
    if (getequippercentrefinery(EQI_HAND_L)<=rand(100)) goto L_Fail;

---------------------------------------

*getareadropitem("<map name>",<x1>,<y1>,<x2>,<y2>,<item>)

This function will count all the items with the specified ID number lying on the 
ground on the specified map within the x1/y1-x2/y2 square on it and return that 
number.

This is the only function around where a parameter may be either a string or a 
number! If it's a number, it means that only the items with that item ID number 
will be counted. If it is a string, it is assumed to mean the 'english name' 
field from the item database. If you give it an empty string, or something that 
isn't found from the item database, it will count items number '512' (apples).

---------------------------------------

*getequipcardcnt(<equipment slot>)

This function will return the number of cards that have been compounded onto a 
specific equipped item for the invoking character. See 'getequipid' for a list 
of possible equipment slots.

---------------------------------------

*getinventorylist;

This command sets a bunch of arrays with a complete list of whatever the 
invoking character has in their inventory, including all the data needed to 
recreate these items perfectly if they are destroyed. Here's what you get:

@inventorylist_id[]        - array of item ids.
@inventorylist_amount[]    - their corresponding item amounts.
@inventorylist_equip[]     - whether the item is equipped or not.
@inventorylist_refine[]    - for how much it is refined.
@inventorylist_identify[]  - whether it is identified.
@inventorylist_attribute[] - whether it is broken.
@inventorylist_card1[]     - These four arrays contain card data for the items.
@inventorylist_card2[]       These data slots are also used to store names
@inventorylist_card3[]       inscribed on the items, so you can explicitly check
@inventorylist_card4[]       if the character owns an item made by a specific 
                             craftsman.
@inventorylist_expire[]    - expire time (Unix time stamp). 0 means never expires.
@inventorylist_bound[]     - whether it is bound to the character
@inventorylist_count       - the number of items in these lists.

This could be handy to save/restore a character's inventory, since no other 
command returns such a complete set of data, and could also be the only way to 
correctly handle an NPC trader for carded and named items who could resell them 
- since NPC objects cannot own items, so they have to store item data in 
variables and recreate the items.

Notice that the variables this command generates are all temporary, attached to 
the character, and integer.

Be sure to use @inventorylist_count to go through these arrays, and not 
'getarraysize', because the arrays are not automatically cleared between runs 
of 'getinventorylist'.

---------------------------------------

*cardscnt()

This function will return the number of cards inserted into the equipment
from which the function is called.

This function is intended for use in item scripts.

---------------------------------------

*getrefine()

This function will return the refine count of the equipment from which the
function is called.

This function is intended for use in item scripts.

---------------------------------------

*getnameditem(<item id>,"<name to inscribe>");
*getnameditem("<item name>","<name to inscribe>");

This function is equivalent to using 'getitem', however, it will not just give 
the character an item object, but will also inscribe it with a specified 
character's name. You may not inscribe items with arbitrary strings, only with 
names of characters that actually exist. While this isn't said anywhere 
specifically, apparently, named items may not have cards in them, slots or no -
these data slots are taken by the character ID who's name is inscribed. Only one 
remains free and it's not quite clear if a card may be there.

This function will return 1 if an item was successfully created and 0 if it
wasn't for whatever reason. Like 'getitem', this function will also accept an
'english name' from the item database as an item name and will return 0 if no
such item exists.

---------------------------------------

*getitemslots(<item ID>)

This function will look up the item with the specified ID number in the database 
and return the number of slots this kind of items has - 0 if they are not 
slotted. It will also be 0 for all non-equippable items, naturally, unless 
someone messed up the item database. It will return -1 if there is no such item.

Example:

//.@slots now has the amount of slots of the item with ID 1205.
	.@slots = getitemslots(1205);

---------------------------------------

*getiteminfo(<item ID>,<type>)

This function will look up the item with the specified ID number in the database 
and return the info set by TYPE argument.
It will return -1 if there is no such item.

Valid types are:
	0  - Buy Price
	1  - Sell Price
	2  - Type
	3  - maxchance (max drop chance of this item, e.g. 1 = 0.01%)
		 if = 0, then monsters don't drop it at all (rare or a quest item)
		 if = 10000, then this item is sold in NPC shops only
	4  - Gender
	5  - Loc
	6  - Weight
	7  - ATK
	8  - DEF
	9  - Range
	10 - Slot
	11 - View
	12 - eLV
	13 - wLV
	14 - SpriteID from 'db/item_avail.txt'
	15 - matk if RENEWAL is defined

See the sample in 'doc/sample/getiteminfo.txt'.

---------------------------------------

*getequipcardid(<equipment slot>,<card slot>)

Returns value from equipped item slot in the indicated slot (0, 1, 2, or 3).

This function returns CARD ID, 255,254,-255 (for card 0, if the item is produced).
It's useful for when you want to check whether an item contains cards or if it's signed.

---------------------------------------
//
2,1.- End of item-related commands.
//
---------------------------------------

*getmapxy("<variable for map name>",<variable for x>,<variable for y>,<type>{,"<search string>"})

This function will locate a character object, NPC object or pet's coordinates 
and place their coordinates into the variables specified when calling it. It 
will return 0 if the search was successful, and -1 if the parameters given were 
not variables or the search was not successful.

Type is the type of object to search for:

  0 - Character object
  1 - NPC object
  2 - Pet object
  3 - Monster object
  4 - Homunculus object
  5 - Mercenary object
  6 - Elemental object
  
While 3 is meant to look for a monster object, no searching will be done if you 
specify type 3, and the function will always return -1.

The search string is optional. If it is not specified, the location of the 
invoking character will always be returned for types 0 and 2, the location of 
the NPC running this function for type 1.
If a search string is specified, for types 0 and 1, the character or NPC with 
the specified name will be located. If type is 3, the search will locate the 
current pet of the character who's name is given in the search string, it will 
NOT locate a pet by name.

Example:

    prontera,164,301,3%TAB%script%TAB%Meh%TAB%730,{
        mes "My name is Meh. I'm here so that Nyah can find me.";
        close;
    }

    prontera,164,299,3%TAB%script%TAB%Nyah%TAB%730,{
        mes "My name is Nyah.";
        mes "I will now search for Meh all across the world!";
        if (getmapxy(@mapname$,@mapx,@mapy,1,"Meh")!=0) {
                mes "I can't seem to find Meh anywhere!";
                close;
        }
        mes "And I found him on map "+@mapname$+" at X:"+@mapx+" Y:"+@mapy+" !";
        close;
   }

Notice that NPC objects disabled with 'disablenpc' will still be located.

---------------------------------------

*getgmlevel()

This function will return the (GM) level associated with the player group to which
the invoking character belongs. If this is somehow executed from a console command,
99 will be returned, and 0 will be returned if the account has no GM level.

This allows you to make NPC's only accessible for certain GM levels, or behave 
specially when talked to by GMs.

   if (getgmlevel()) mes "What is your command, your godhood?";

---------------------------------------

*getgroupid()

This function will return the group id to which the invoking player belongs.

---------------------------------------

*gettimetick(<tick type>)

This function will return a tick depending on <tick type>:
 0: The server's tick, a measurement in milliseconds used by the server's timer
    system. This tick is an unsigned int which loops every ~50 days.
 1: The time, in seconds, since the start of the current day.
 2: The system time in UNIX epoch time, or the number of seconds elapsed since
    January 1st, 1970. Useful for reliably measuring time intervals.

---------------------------------------

*gettime(<type>)

This function will return specified information about the current system time.

1 - Seconds (of a minute)
2 - Minutes (of an hour)
3 - Hour (of a day)
4 - Week day (0 for Sunday, 6 is Saturday)
5 - Day of the month.
6 - Number of the month.
7 - Year.
8 - Day of the year.

It will only return numbers.

    if (gettime(4)==6) mes "It's a Saturday. I don't work on Saturdays.";

---------------------------------------

*gettimestr(<format string>,<max length>)

This function will return a string containing time data as specified by the 
format string.

This uses the C function 'strfmtime', which obeys special format characters. For 
a full description see, for example, the description of 'strfmtime' at 
http://www.delorie.com/gnu/docs/glibc/libc_437.html
All the format characters given in there should properly work.
Max length is the maximum length of a time string to generate.

The example given in rAthena sample scripts works like this:

  mes gettimestr("%Y-%m/%d %H:%M:%S",21);
  
This will print a full date and time like 'YYYY-MM/DD HH:MM:SS'.

---------------------------------------

*getusers(<type>)

This function will return a number of users on a map or the whole server. What 
it returns is specified by Type.

Type can be one of the following values, which control what will be returned:

    0 - Count of all characters on the map of the invoking character.
    1 - Count of all characters in the entire server.
    8 - Count of all characters on the map of the NPC the script is
        running in.

---------------------------------------

*getmapusers("<map name>")

This function will return the number of users currently located on the specified 
map.

This is used officially in PVP scripts to check whether a room is filled to capacity.

---------------------------------------

*getareausers("<map name>",<x1>,<y1>,<x2>,<y2>)

This function will return the count of connected characters which are located 
within the specified area - an x1/y1-x2/y2 square on the specified map.

This is useful for maps that are split into many buildings, such as all the 
"*_in" maps, due to all the shops and houses.

---------------------------------------

*getusersname;

This command will give the invoking character a list of names of the connected 
characters (including themselves) into an NPC script message window (see 'mes') 
paging it by 10 names as if with the 'next' command.

You need to put a 'close' after that yourself.

---------------------------------------
\\
2,2.- Guild-related commands
\\
---------------------------------------

*getguildname(<guild id>)

This function returns a guild's name given an ID number. If there is no such 
guild, "null" will be returned.

Example:
	mes "The guild "+getguildname(10007)+" are all nice people.";

---------------------------------------

*getguildmember <guild id>{,<type>};

This command will find all members of a specified guild and returns their names 
(or character id or account id depending on the value of "type") into an array
of temporary global variables.

Upon executing this,

$@guildmembername$[] is a global temporary string array which contains all the 
                     names of these guild members.
                     (only set when type is 0 or not specified)

$@guildmembercid[]   is a global temporary number array which contains the 
                     character id of these guild members.
                     (only set when type is 1)

$@guildmemberaid[]   is a global temporary number array which contains the 
                     account id of these guild members.
                     (only set when type is 2)

$@guildmembercount   is the number of guild members that were found.

The guild members will be found regardless of whether they are online or offline.
Note that the names come in no particular order.

Be sure to use $@guildmembercount to go through this array, and not 
'getarraysize', because it is not cleared between runs of 'getguildmember'.

For usage examples, see 'getpartymember'.

---------------------------------------

*getguildmaster(<guild id>)

This function return the name of the master of the guild which has the specified 
ID number. If there is no such guild, "null" will be returned.

Example 1:
	// Prints the guild master of guild 10007, whoever that might be.
	mes getguildmaster(10007)+" runs "+getguildname(10007);

Example 2:
	// Checks if the character is the guild master of the specified guild.
	.@GID = getcharid(2);
	if (.@GID == 0) {
		mes "Sorry, you are not in a guild.";
		close;
	}
	if (strcharinfo(0) != getguildmaster(.@GID)) {
		mes "Sorry, you don't own the guild you are in.";
		close;
	}
        mes "Welcome, guild master of "+getguildname(.@GID);
        close;

---------------------------------------

*getguildmasterid(<guild id>)

This function will return the character ID number of the guild master of the 
guild specified by the ID. 0 if the character is not a guild master of any guild.

---------------------------------------

*getcastlename("<map name>")

This function returns the name of the castle when given the map name for that 
castle. The data is read from 'db/castle_db.txt'.

---------------------------------------

*getcastledata("<map name>",<type of data>)
*setcastledata "<map name>",<type of data>,<value>;

This function returns the castle ownership information for the castle referred 
to by its map name. Castle information is stored in `guild_castle` SQL table.

Types of data correspond to `guild_castle` table columns:

 1 - `guild_id`   - Guild ID.
 2 - `economy`    - Castle Economy score.
 3 - `defense`    - Castle Defense score.
 4 - `triggerE`   - Number of times the economy was invested in today.
 5 - `triggerD`   - Number of times the defense was invested in today.
 6 - `nextTime`   - unused
 7 - `payTime`    - unused
 8 - `createTime` - unused
 9 - `visibleC`   - Is 1 if a Kafra was hired for this castle, 0 otherwise.
10 - `visibleG0`  - Is 1 if the 1st guardian is present (Soldier Guardian)
11 - `visibleG1`  - Is 1 if the 2nd guardian is present (Soldier Guardian)
12 - `visibleG2`  - Is 1 if the 3rd guardian is present (Soldier Guardian)
13 - `visibleG3`  - Is 1 if the 4th guardian is present (Archer Guardian)
14 - `visibleG4`  - Is 1 if the 5th guardian is present (Archer Guardian)
15 - `visibleG5`  - Is 1 if the 6th guardian is present (Knight Guardian)
16 - `visibleG6`  - Is 1 if the 7th guardian is present (Knight Guardian)
17 - `visibleG7`  - Is 1 if the 8th guardian is present (Knight Guardian)

All types of data have their meaning determined by War of Emperium scripts, 
with exception of:
 - `guild_id` that is always considered ID of the guild that owns the castle,
 - `defense` that is used in Guardians & Emperium HP calculations,
 - `visibleG` that is always considered to hold guardian presence bits.

The 'setcastledata' command will behave identically, but instead of returning 
values for the specified types of accessible data, it will alter them and cause 
them to be sent to the char-server for storage.

Changing Guild ID or Castle Defense will trigger additional actions, like 
recalculating guardians' HP.

---------------------------------------

*getgdskilllv(<guild id>,<skill id>)
*getgdskilllv(<guild id>,"<skill name>")

This function returns the level of the skill <skill id> of the guild <guild id>.
If the guild does not have that skill, 0 is returned.
If the guild does not exist, -1 is returned.
Refer to 'db/(pre-)re/skill_db.txt' for the full list of skills. (GD_* are guild skills)

---------------------------------------

*requestguildinfo <guild id>{,"<event label>"};

This command requests the guild data from the char server and merrily continues 
with the execution. Whenever the guild information becomes available (which 
happens instantly if the guild information is already in memory, or later, if it 
isn't and the map server has to wait for the char server to reply) it will run 
the specified event as in a 'doevent' call.

---------------------------------------

*getmapguildusers("<map name>",<guild id>)

Returns the amount of characters from the specified guild on the given map.

Example:

mes "You have "+getMapGuildUsers("prontera",getcharid(2))+" guild members in Prontera.";

---------------------------------------
//
2,2.- End of guild-related commands
//
---------------------------------------

*getskilllv(<skill id>)
*getskilllv("<skill name>")

This function returns the level of the specified skill that the invoking 
character has. If they don't have the skill, 0 will be returned. The full list 
of character skills is available in 'db/(pre-)re/skill_db.txt'.

There are two main uses for this function, it can check whether the character 
has a skill or not, and it can tell you if the level is high enough.

Example 1:

        if (getskilllv(152)) goto L_HasSkillThrowStone;
        mes "You don't have Throw Stone";
        close;
    L_HasSkillThrowStone:
        mes "You have got the skill Throw Stone";
        close;

Example 2:

        if (getskilllv(28) >= 5) goto L_HasSkillHeallvl5orMore;
        if (getskilllv(28) == 10) goto L_HasSkillHealMaxed;
        mes "You heal skill is below lvl 5";
        close;
    L_HasSkillHeallvl6orMore:
        mes "Your heal lvl is 5 or more";
        close;
    L_HasSkillHealMaxed:
        mes "Your heal lvl has been maxed";
        close;

---------------------------------------

*getskilllist;

This command sets a bunch of arrays with a complete list of skills the
invoking character has. Here's what you get:

@skilllist_id[]   - skill ids.
@skilllist_lv[]   - skill levels.
@skilllist_flag[] - see 'skill' for the meaning of skill flags.
@skilllist_count  - number of skills in the above arrays.

While 'getskillv' is probably more useful for most situations, this is the 
easiest way to store all the skills and make the character something else for a 
while. Advanced job for a day? :) This could also be useful to see how many 
skills a character has.

This command does not count skills which are set as flag 4 (permament granted) (ALL_BUYING_STORE/ALL_INCCARRY)

---------------------------------------

*getmonsterinfo(<mob ID>,<type>)

This function will look up the monster with the specified ID number in the
mob database and return the info set by TYPE argument.
It will return -1 if there is no such monster (or the type value is invalid),
or "null" if you requested the monster's name.

Valid types are listed in 'db/const.txt':
	MOB_NAME	0
	MOB_LV	1
	MOB_MAXHP	2
	MOB_BASEEXP	3
	MOB_JOBEXP	4
	MOB_ATK1	5
	MOB_ATK2	6
	MOB_DEF	7
	MOB_MDEF	8
	MOB_STR	9
	MOB_AGI	10
	MOB_VIT	11
	MOB_INT	12
	MOB_DEX	13
	MOB_LUK	14
	MOB_RANGE	15
	MOB_RANGE2	16
	MOB_RANGE3	17
	MOB_SIZE	18
	MOB_RACE	19
	MOB_ELEMENT	20
	MOB_MODE	21
	MOB_MVPEXP	22

For more details, see the sample in 'doc/sample/getmonsterinfo.txt'.

---------------------------------------

*getmobdrops(<mob id>)

This command will find all drops of the specified mob and return the item IDs 
and drop percentages into arrays of temporary global variables. 
'getmobdrops' returns 1 if successful and 0 if the mob ID doesn't exist.

Upon executing this,

$@MobDrop_item[] is a global temporary number array which contains the 
                 item IDs of the monster's drops.

$@MobDrop_rate[] is a global temporary number array which contains the 
                 drop percentages of each item. (1 = .01%)

$@MobDrop_count is the number of item drops found.

Be sure to use $@MobDrop_count to go through the arrays, and not 
'getarraysize', because the temporary global arrays are not cleared between 
runs of 'getmobdrops'. If a mob with 7 item drops is looked up, the arrays would 
have 7 elements. But if another mob is looked up and it only has 5 item drops, 
the server will not clear the arrays for you, overwriting the values instead. So 
in addition to returning the 5 item drops, the 6th and 7th elements from the 
last call remain, and you will get 5+2 item drops, of which the last 2 don't 
belong to the new mob. $@MobDrop_count will always contain the correct number 
(5), unlike 'getarraysize()' which would return 7 in this case.

Example:

	// get a Mob ID from the user
	input .@mob_id;
	
	if (getmobdrops(.@mob_id)) {	// 'getmobdrops' returns 1 on success
		// immediately copy global temporary variables into scope variables, 
		// since we don't know when 'getmobdrops' will get called again for 
		// another mob, overwriting your global temporary variables
		.@count = $@MobDrop_count;
		copyarray .@item[0],$@MobDrop_item[0],.@count;
		copyarray .@rate[0],$@MobDrop_rate[0],.@count;
		
		mes getmonsterinfo(.@mob_id,MOB_NAME) + " - " + .@count + " drops found:";
		for( .@i = 0; .@i < .@count; .@i++ ) {
			mes .@item[.@i] + " (" + getitemname(.@item[.@i]) + ") " + .@rate[.@i]/100 + ((.@rate[.@i]%100 < 10) ? ".0":".") + .@rate[.@i]%100 + "%";
		}
	} else {
		mes "Unknown monster ID.";
	}
	close;

---------------------------------------

*skillpointcount()

Returns the total amount of skill points a character possesses (SkillPoint+SP's used in skills)
This command can be used to check the currently attached characters total amount of skill points.
This means the skill points used in skill are counted, and added to SkillPoints (number of skill points not used).
This command does not count skills which are set as flag 4 (permament granted) (ALL_BUYING_STORE/ALL_INCCARRY)

Example 1:
	.@skillPoints = skillpointcount();
	mes "You have " + .@skillPoints + " skill points in total!";

Example 2:
	if (skillpointcount() > 20)
		mes "Wow, you have more then 20 Skill Points in total!";

---------------------------------------

*getscrate(<effect type>,<base rate>{,<GID>})

This function will return the chance of a status effect affecting the invoking 
character, in percent, modified by the their current defense against said 
status. The 'base rate' is the base chance of the status effect being inflicted, 
in percent.

    if (rand(100) > getscrate(Eff_Blind, 50)) goto BlindHimNow;
  
You can see the full list of available effect types you can possibly inflict in 
'db/const.txt' under 'Eff_'.

---------------------------------------

========================
|3.- Checking commands.|
========================
-------------------------

*playerattached()

Returns the ID of the player currently attached to the script. It will return
0 if no one is attached, or if the attached player no longer exists on the map
server. It is wise to check for the attached player in script functions that
deal with timers as there's no guarantee the player will still be logged on
when the timer triggers. Note that the ID of a player is actually their
account ID.

---------------------------------------

*isloggedin(<account id>{,<char id>})

This function returns 1 if the specified account is logged in and 0 if they 
aren't. You can also pass the char id to check for both account and char id.

---------------------------------------

*checkweight(<item id>,<amount>{,<item id>,<amount>,<item id>,<amount>,...});
*checkweight("<item name>",<amount>{,"<item name>",<amount>,"<item name>",<amount>,...});
*checkweight2(<id_array>,<amount_array>);

These functions will compute and return 1 if the total weight of the specified 
number of specific items does not exceed the invoking character's carrying 
capacity, and 0 otherwise. It is important to see if a player can carry the 
items you expect to give them, failing to do that may open your script up to 
abuse or create some very unfair errors.

The second function will check an array of items and amounts, and also
returns 1 on success and 0 on failure.

The functions, in addition to checking to see if the player is capable of 
holding a set amount of items, also ensure the player has room in their 
inventory for the item(s) they will be receiving.

Like 'getitem', this function will also accept an 'english name' from the 
database as an argument.

Example 1:

	if (checkweight(512,10)) {
		getitem 512,10;
	} else {
		mes "Sorry, you cannot hold this amount of apples!";
	}

Example 2:

	setarray .@item[0],512,513,514;
	setarray .@amount[0],10,5,5;
	if (!checkweight(.@item,.@amount)) {
		mes "Sorry, you cannot hold this amount of fruit!";
	}

---------------------------------------

*basicskillcheck()

This function will return the state of the configuration option 
'basic_skill_check' in 'battle_athena.conf'. It returns 1 if the option is 
enabled and 0 if it isn't. If the 'basic_skill_check' option is enabled, which 
it is by default, characters must have a certain number of basic skill levels to 
sit, request a trade, use emotions, etc. Making your script behave differently 
depending on whether the characters must actually have the skill to do all these 
things might in some cases be required.

---------------------------------------

*checkoption(<option number>)
*checkoption1(<option number>)
*checkoption2(<option number>)
*setoption <option number>{,<flag>};

The 'setoption' series of functions check for a so-called option that is set on 
the invoking character. 'Options' are used to store status conditions and a lot 
of other non-permanent character data of the yes-no kind. For most common cases, 
it is better to use 'checkcart','checkfalcon','checkriding' and other similar 
functions, but there are some options which you cannot get at this way. They 
return 1 if the option is set and 0 if the option is not set.

Option numbers valid for the first (option) version of this command are:

0x1       - Sight in effect.
0x2       - Hide in effect.
0x4       - Cloaking in effect.
0x8       - Cart number 1 present.
0x10      - Falcon present.
0x20      - Peco Peco present.
0x40      - GM Perfect Hide in effect.
0x80      - Cart number 2 present.
0x100     - Cart number 3 present.
0x200     - Cart number 4 present.
0x400     - Cart number 5 present.
0x800     - Orc head present.
0x1000    - The character is wearing a wedding sprite.
0x2000    - Ruwach is in effect.
0x4000    - Chasewalk in effect.
0x8000    - Flying or Xmas suit.
0x10000   - Sighttrasher.
0x100000  - Warg present.
0x200000  - The character is riding a warg.

Option numbers valid for the second version (opt1) of this command are:

1 - Petrified.
2 - Frozen.
3 - Stunned.
4 - Sleeping.
6 - Petrifying (the state where you can still walk)

Option numbers valid for the third version (opt2) of this command are:

0x1  - Poisoned.
0x2  - Cursed.
0x4  - Silenced.
0x8  - Signum Crucis (plays a howl-like sound effect, but otherwise no visible effects are displayed)
0x10 - Blinded.
0x80 - Deadly poisoned.

Option numbers (except for opt1) are bit-masks - you can add them up to check
for several states, but the functions will return true if at least one of them
is in effect.

'setoption' will set options on the invoking character. There are no second and 
third versions of this command, so you can only change the values in the first 
list (cloak, cart, ruwach, etc). if flag is 1 (default when omitted),
the option will be added to what the character currently has; if 0, the option is removed. 

This is definitely not a complete list of available option flag numbers. Ask a 
core developer (or read the source: src/map/status.h) for the full list.

---------------------------------------

*setcart {<type>};
*checkcart()

If <type> is 0 this command will remove the cart from the character.
Otherwise it gives the invoking character a cart. The cart given will be 
cart number <type> and will work regardless of whether the character is a 
merchant class or not.
Note: the character needs to have the skill MC_PUSHCART to gain a cart

The accompanying function will return 1 if the invoking character has a cart 
(any kind of cart) and 0 if they don't.

    if (checkcart()) mes "But you already have a cart!";

---------------------------------------

*setfalcon {<flag>};
*checkfalcon()

If <flag> is 0 this command will remove the falcon from the character.
Otherwise it gives the invoking character a falcon. The falcon will be there 
regardless of whether the character is a hunter or not. It will (probably) not 
have any useful effects for non-hunters though.
Note: the character needs to have the skill HT_FALCON to gain a falcon

The accompanying function will return 1 if the invoking character has a falcon 
and 0 if they don't.

    if (checkfalcon()) mes "But you already have a falcon!";

---------------------------------------

*setriding {<flag>};
*checkriding()

If <flag> is 0 this command will remove the mount from the character.
Otherwise it gives the invoking character a PecoPeco (if they are a Knight 
series class), a GrandPeco (if they are a Crusader series class), or
a Gryphon (if they are a Royal Guard). Unlike 'setfalcon' and 'setcart'
this will not work at all if they aren't of a class which can ride.
Note: the character needs to have the skill KN_RIDING to gain a mount

The accompanying function will return 1 if the invoking character is riding a 
bird and 0 if they aren't.

    if (checkriding()) mes "PLEASE leave your bird outside! No riding birds on the floor here!";

---------------------------------------

*setdragon {<color>};
*checkdragon()

The 'setdragon' function toggles mounting a dragon for the invoking character.
It will return 1 if successful, 0 otherwise.

The available colors are:
 1 - Green Dragon (default)
 2 - Brown Dragon
 3 - Gray Dragon
 4 - Blue Dragon
 5 - Red Dragon

Note: the character must be a Rune Knight and have the skill RK_DRAGONTRAINING to gain a mount

The accompanying function will return 1 if the invoking character is riding a 
dragon and 0 if they aren't.

---------------------------------------

*setmadogear {<flag>};
*checkmadogear()

If <flag> is 0 this command will remove the mount from the character.
Otherwise it gives the invoking character a Mado (if they are a Mechanic).

The accompanying function will return 1 if the invoking character has a
Mado and 0 if they don't.

---------------------------------------

*setmounting;
*ismounting()

The 'setmounting' function toggles cash mount for the invoking character.
It will return 1 if successful, 0 otherwise.

Note: Character must not be mounting a non-cash mount (eg. dragon, peco, wug, etc.)

The accompanying function will return 1 if the invoking character has a
cash mount and 0 if they don't.

---------------------------------------

*checkwug()

This function will return 1 if the invoking character has a
warg and 0 if they don't.

---------------------------------------

*checkvending({"<Player Name>"})
*checkchatting({"<Player Name>"})

Checks if the player is vending or in a chatroom.
Name is optional, and defaults to the attached player if omitted.

Return values for 'checkvending' are
  0 = not vending
  1 = normal vending
  2 = vending using @autotrade

'checkchatting' returns 1 if they are in a chat room, 0 if they are not.

Examples:
	//This will check if Aaron is vending, and if so, put a message in front
	//of the attached player saying Aaron is vending.
	if (checkvending("Aaron"))
		mes "Aaron is currently vending!";

	//This will check if the attached player in a chat room or not.
	if (checkchatting())
		mes "You are currently in a chat room!";

---------------------------------------

*checkidle({"<Player Name>"})

Returns the time, in seconds, that the specified player has been idle.
Name is optional, and defaults to the attached player if omitted.

---------------------------------------

*agitcheck()
*agitcheck2()

These function will let you check whether the server is currently in WoE mode
(or WoE SE mode if the second function is called) and will return 1 if War of
Emperium is on and 0 if it isn't. 

---------------------------------------

*isnight()
*isday()

These functions will return 1 or 0 depending on whether the server is in night 
mode or day mode. 'isnight' returns 1 if it's night and 0 if it isn't, 'isday' 
the other way around. They can be used interchangeably, pick the one you like 
more:

    // These two are equivalent:
    if (isday()) mes "I only prowl in the night.";
    if (isnight()!=1) mes "I only prowl in the night.";

---------------------------------------

*checkre(<type>)

Checks if a renewal feature is enabled or not in renewal.h, and returns 1 if
enabled and 0 for disabled.

The renewal feature to check is determined by type.
 0 - RENEWAL (game renewal server mode)
 1 - RENEWAL_CAST (renewal cast time)
 2 - RENEWAL_DROP (renewal drop rate algorithms)
 3 - RENEWAL_EXP (renewal exp rate algorithms)
 4 - RENEWAL_LVDMG (renewal level modifier on damage)
 5 - RENEWAL_ASPD (renewal ASPD)

---------------------------------------

*is_clientver(<type>,<value>{,<char id>})

Checks a character's client version against a specified value. If no char id is
given, the command will run for the invoking character. The function will return
1 if the player's version is greater than or equal to the value, and 0 otherwise.

Available types are:
 0 - version number (packet_db_ver)
 1 - client date (YYYYMMDD)

---------------------------------------
\\
3,1.- Item-related commands
\\
---------------------------------------

*isequipped(<id>{,<id>{,<id>{,<id>}}})

This function will return 1 if the invoking character has all of the item 
IDs given equipped (if card IDs are passed, then it checks if the cards are
inserted into slots in the equipment they are currently wearing). Theoretically
there is no limit to the number of items that may be tested for at the same time. 
If even one of the items given is not equipped, 0 will be returned.

    // (Poring,Santa Poring,Poporing,Marin)
    if (isequipped(4001,4005,4033,4196)) mes "Wow! You're wearing a full complement of possible poring cards!";
    // (Poring)
    if (isequipped(4001)) mes "A poring card is useful, don't you think?";
    
The function was meant for item scripts to support the cards released by Gravity 
in February 2005, but it will work just fine in normal NPC scripts.

---------------------------------------

*isequippedcnt(<card id>{,<card id>{,<card id>{,<card id>}}})

This function is similar to 'isequipped', but instead of 1 or 0, it will return 
the number of cards in the list given that were found on the invoking character.

If a given parameter is not a card, the function returns the amount of that
item equipped on the invoking character.

    if (isequippedcnt(4001,4005,4033,4196) == 4) mes "Finally got all four poring cards?";

---------------------------------------

*checkequipedcard(<card id>)

This function will return 1 if the card specified by its item ID number is 
inserted into any equipment they have in their inventory, currently equipped or 
not.

---------------------------------------
//
3,1.- End of item-related commands
//
---------------------------------------

==============================
|4.- Player-related commands.|
==============================
-------------------------

*attachrid(<account ID>)
*detachrid;

These commands allow the manipulation of the script's currently attached player.
While 'attachrid' allows attaching of a different player by using its account id
for the parameter RID, 'detachrid' makes the following commands run as if the
script was never invoked by a player. 

The command returns 0 if the player cannot be attached (if the account is offline
or does not exist), and 1 upon success.

-------------------------

*addrid(<type>{,<flag>{,<parameters>}});

This command will attach other RIDs to the current script without detaching the
invoking RID. It returns 1 if successful and 0 upon failure.

<type> determines what RIDs are attached:
 0: All players in the server.
 1: All players in the map of the invoking player, or the invoking NPC if no player is attached.
 2: Party members of a specified party ID.
    [ Parameters: <party id> ]
 3: Guild members of a specified guild ID.
    [ Parameters: <guild id> ]
 4: All players in a specified area of the map of the invoking player (or NPC).
    [ Parameters: <x0>,<y0>,<x1>,<y1> ]
 Account ID: The specified account ID.

<flag> can prevent certain players from being attached:
 0: Players are always attached. (default)
 1: Players currently running another script will not be attached.

---------------------------------------

*rid2name(<rid>)

Converts rid to name. Note: The player/monster/NPC must be online/enabled.
Good for PCKillEvent where you can convert 'killedrid' to the name of the player.

Note: rid2name may not produce correct character names since rid = account id.
      It will return the current online character of the account only.

---------------------------------------

*message "<character name>","<message>";

That command will send a message to the chat window of the character specified 
by name. The text will also appear above the head of that character. It will not 
be seen by anyone else.

---------------------------------------

*dispbottom "<message>";

This command will send the given message into the invoking character's chat 
window.

---------------------------------------

*warp "<map name>",<x>,<y>;

This command will take the invoking character to the specified map, and if 
wanted, specified coordinates too, but these can be random.

    warp "place",50,55;

This would take them to X 50 Y 55 on the map called "place". If your X and Y 
coordinates land on an unwalkable map square, it will send the warped character 
to a random place. Same will happen if they are both zero:

    warp "place",0,0;

Notice that while warping people to coordinates 0,0 will normally get them into 
a random place, it's not certain to always be so. Darned if I know where this is 
actually coded, it might be that this happens because square 0,0 is unwalkable 
on all official maps. If you're using custom maps, beware.

There are also three special 'map names' you can use.

"Random" will warp the player randomly on the current map.
"Save" and "SavePoint" will warp the player back to their save point.

---------------------------------------

*areawarp "<from map name>",<x1>,<y1>,<x2>,<y2>,"<to map name>",<x3>,<y3>{,<x4>,<y4>};

This command is similar to 'warp', however, it will not refer to the invoking 
character, but instead, all characters within a specified area, defined by the 
x1/y1-x2/y2 square, will be warped. Nobody outside the area will be affected, 
including the activating character, if they are outside the area.

    areawarp "place",10,10,120,120,"place2",150,150;

Everyone that is in the area between X 10 Y 10 and X 120 Y 120, in a square 
shape, on the map called "place", will be affected, and warped to "place2" X 150 
Y 150

    areawarp "place",10,10,120,120,"place2",0,0;

By using ,0,0; as the destination coordinates it will take all the characters in 
the affected area to a random set of co-ordinates on "place2".

    areawarp "place",10,10,120,120,"place2",150,150,200,200;

By using the optional x4 and y4 parameters, the destination coordinates will be a 
random place within the defined x3/y3-x4/y4 square.

Like 'warp', areawarp will also explicitly warp characters randomly into the 
current map if you give the 'to map name' as "Random".

See also 'warp'.

---------------------------------------
 
*warpparty "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>"};
 
Warps a party to specified map and coordinate given the party ID, which you can get with
getcharid(1). You can also request another party id given a member's name with getcharid(1,<player_name>).

You can use the following "map names" for special warping behavior:
Random:       All party members are randomly warped in their current map (as if they
              all used a fly wing)
SavePointAll: All party members are warped to their respective save point.
SavePoint:    All party members are warped to the save point of the currently
              attached player (will fail if there's no player attached).
Leader:       All party members are warped to the leader's position. The leader must
              be online and in the current map-server for this to work.

If you specify a from_mapname, 'warpparty' will only affect those on that map.

Example:
	mes "[Party Warper]";
	mes "Here you go!";
	close2;
	.@party_id = getcharid(1);
	warpparty "prontera",150,100,.@party_id;
	close;

---------------------------------------

*warpchar "<map name>",<x>,<y>,<char id>;

Warps another player to specified map and coordinate given the char id, which you can get with
getcharid(0,<player_name>). Obviously this is useless if you want to warp the same player that
is executing this script, unless it's some kind of "chosen" script. 
 
Example:
 
warpchar "prontera",150,100,150001;

---------------------------------------

*warpguild "<map name>",<x>,<y>,<guild_id>;
 
Warps a guild to specified map and coordinate given the guild id, which you can get with 
getcharid(2). You can also request another guild id given the member's name with getcharid(2,<player_name>).

You can use the following "map names" for special warping behavior:
Random:       All guild members are randomly warped in their current map (as if they
              all used a fly wing)
SavePointAll: All guild members are warped to their respective save point.
SavePoint:    All guild members are warped to the save point of the currently
              attached player (will fail if there's no player attached).

Example:

warpguild "prontera",x,y,Guild_ID;

---------------------------------------

*warppartner("<map name>",<x>,<y>);

This function will find the invoking character's marriage partner, if any, and 
warp them to the map and coordinates given. Go kidnap that spouse. :) It will 
return 1 upon success and 0 if the partner is not online, the character is not 
married, or if there's no invoking character (no RID). 0,0 will, as usual, 
normally translate to random coordinates.

---------------------------------------

*savepoint "<map name>",<x>,<y>;
*save "<map name>",<x>,<y>;

These commands save where the invoking character will return to upon clicking
"Return to Save Point", after death and in some other cases. The two versions are 
equivalent. They ignore any and all mapflags, and can make a character respawn where
no teleportation is otherwise possible.

    savepoint "place",350,75;

---------------------------------------

*heal <hp>,<sp>;

This command will heal a set amount of HP and/or SP on the invoking character.

    heal 30000,0; // This will heal 30,000 HP
    heal 0,30000; // This will heal 30,000 SP
    heal 300,300; // This will heal 300 HP and 300 SP

This command just alters the hit points and spell points of the invoking 
character and produces no other output whatsoever.

---------------------------------------

*itemheal <hp>,<sp>;

This command heals relative amounts of HP and/or SP on the invoking character.
Unlike heal, this command is intended for use in item scripts. It applies
potion-related bonuses, such as alchemist ranking, cards, and status changes.
When used inside an NPC script, certain bonuses are omitted.

The command also applies a SP/VIT-related bonus:
    heal = heal * [(100 + STATUS*2) / 100]

Example:
    // If the player has 50 vit and no bonuses, this will heal
    // anything from 200 to 300 HP and 5 SP
    itemheal rand(100,150),5;

---------------------------------------

*percentheal <hp>,<sp>;

This command will heal the invoking character. It heals the character, but not 
by a set value - it adds percent of their maximum HP/SP.

    percentheal 100,0; // This will heal 100% HP
    percentheal 0,100; // This will heal 100% SP
    percentheal 50,50; // This will heal 50% HP and 50% SP

So the amount that this will heal will depend on the total amount of HP or SP 
you have maximum. Like 'heal', this will not call up any animations or effects.

---------------------------------------

*recovery <type>{,<option>,<revive_flag>{,<map name>}};

This command will revive and fully restore the HP/SP of the selected characters.
It returns 1 upon successful use.

<type> is the target, and determines the <option> parameter:
 0: Player  -> Character ID number
 1: Party   -> Party ID number
 2: Guild   -> Guild ID number
 3: Map     -> Map name (a string)
 4: All     -> None (takes <revive_flag> as option)

If no option is specified, the invoking player's character ID, party ID, guild ID,
or map will be used.

<revive_flag> determines the action:
 1: Revive and heal all players (default)
 2: Heal living players only
 4: Revive dead players only

<map name> can optionally be used to define a single map to execute the command on
for types 1 (party) and 2 (guild).

Examples:
	// Only revive characters in invoking party on map "morocc"
	recovery 1,getcharid(1),4,"morocc";

	// Fully heal (don't revive) all members of invoking character's guild
	recovery 2,getcharid(2),2;

	// Revive and fully heal everyone in map "prontera"
	recovery 3,"prontera";

	// Only revive all dead characters on server
	recovery 4,4;

---------------------------------------

*jobchange <job number>{,<upper flag>};

This command will change the job class of the invoking character.

    jobchange 1; // This would change your player into a Swordman
    jobchange 4002; // This would change your player into a Swordman High

This command does work with numbers, but you can also use job names. The full 
list of job names and the numbers they correspond to can be found in 
'db/const.txt'.

    // This would change your player into a Swordman
    jobchange Job_Swordman;
    // This would change your player into a Swordman High
    jobchange Job_Swordman_High;

'upper flag' can alternatively be used to specify the type of job one changes
to. For example, jobchange Job_Swordman,1; will change the character to a high
swordsman. The upper values are:
-1 (or when omitted): preserves the current job type.
0: Normal/standard classes
1: High/Advanced classes
2: Baby classes

This command will also set a permanent character-based variable 
'jobchange_level' which will contain the job level at the time right before 
changing jobs, which can be checked for later in scripts.

---------------------------------------

*jobname(<job number>)

This command retrieves the name of the given job using the map_msg entries 550->655.

	mes "[Kid]";
	mes "I never thought I'd met a "+jobname(Class)+" here of all places.";
	close;

---------------------------------------

*eaclass({<job number>})

This commands returns the "eA job-number" corresponding to the given class, and
uses the invoking player's class if none is given. The eA job-number is also a
class number system, but it's one that comes with constants which make it easy
to convert among classes. The command will return -1 if you pass it a job number
which doesn't have an eA job-number equivalent.

	@eac = eaclass();
	if ((@eac&EAJ_BASEMASK) == EAJ_SWORDMAN)
		mes "Your base job is Swordman.";
	if (@eac&EAJL_UPPER)
		mes "You are a rebirth job.";
	if ((@eac&EAJ_UPPERMASK) == EAJ_SWORDMAN)
		mes "You must be a Swordman, Baby Swordman or High Swordman.";

For more information on the eA Job System, see the docs/ea_job_system.txt file.

---------------------------------------

*roclass(<job number>{,<gender>})

Does the opposite of eaclass. That is, given an eA job-number, it returns the
corresponding RO class number. A gender is required because both Bard and Dancers
share the same eA job-number (EAJ_BARDDANCER), and uses the invoking player's
gender if none is given (if no player is attached, male will be used by default).
The command will return -1 if there is no valid class to represent the specified
job (for example, if you try to get the baby version of a Taekwon class).

	@eac = eaclass();
	//Check if class is already rebirth
	if (@eac&EAJL_UPPER) {
		mes "You look strong.";
		close;
	}
	@eac = roclass(@eac|EAJL_UPPER);
	//Check if class has a rebirth version
	if (@eac != -1) {
		mes "Bet you can't wait to become a "+jobname(@eac)+"!";
		close;
	}

---------------------------------------

*changebase <job ID number>{,<account ID>};

This command will change a character's appearance to that of the specified job
class. Nothing but appearance will change.

The command will run for the invoking character unless an account ID is given.

	changebase Job_Novice; // Changes player to Novice sprite.
	changebase Class; // Changes player back to default sprite.

---------------------------------------

*classchange <view id>,<type>;

This command is very ancient, its origins are clouded in mystery. 
It will send a 'display id change' packet to everyone in the immediate area of 
the NPC object, which will supposedly make the NPC look like a different sprite, 
an NPC sprite ID, or a monster ID. This effect is not stored anywhere and will 
not persist (Which is odd, cause it would be relatively easy to make it do so) 
and most importantly, will not work at all since this command was broken with 
the introduction of advanced classes. The code is written with the assumption 
that the lowest sprite IDs are the job sprites and the anything beyond them is 
monster and NPC sprites, but since the advanced classes rolled in, they got the 
ID numbers on the other end of the number pool where monster sprites float.

As a result it is currently impossible to call this command with a valid view 
id. It will do nothing whatsoever if the view ID is below 4047. Getting it to 
run will actually just crash the client.

It could be a real gem if it can be gotten to actually do what it's supposed to 
do, but this will only happen in a later SVN revision.

---------------------------------------

*changesex;

This command will change the gender for the attached character's account. If it 
was male, it will become female, if it was female, it will become male. The 
change will be written to the character server, the player will receive the 
message: "Need disconnection to perform change-sex request..." and the player 
will be immediately kicked to the login screen. When they log back in, they will 
be the opposite sex.

If there are any Dancer/Gypsy or Bard/Clown characters on the account, 
they will also have their skills reset upon 'changesex'.

---------------------------------------

*getexp <base xp>,<job xp>;

This command will give the invoking character a specified number of base and job 
experience points. Can be used as a quest reward. Negative values won't work.

    getexp 10000,5000;

You can also use the "set" command with the constants defined in 'db/const.txt':

    // These 2 combined has the same effect as the above command
    set BaseExp,BaseExp+10000;
    set JobExp,JobExp+5000;

You can also reduce the amount of experience points:

    set BaseExp,BaseExp-10000;

Note that 'getexp' is now subject to the 'quest_exp_rate' config option, which
adjusts the gained value. If you want to bypass this, use the 'set' method.

---------------------------------------

*setlook <look type>,<look value>;
*changelook <look type>,<look value>;

'setlook' will alter the look data for the invoking character. It is used 
mainly for changing the palette used on hair and clothes: you specify which look 
type you want to change, then the palette you want to use. Make sure you specify 
a palette number that exists/is usable by the client you use.
'changelook' works the same, but is only client side (it doesn't save the look value).

    // This will change your hair(6), so that it uses palette 8, what ever your 
    // palette 8 is, your hair will use that color

    setlook 6,8;

    // This will change your clothes(7), so they are using palette 1, whatever 
    // your palette 1 is, your clothes will then use that set of colors.
    
    setlook 7,1;

Here are the possible look types:

 0 - Base sprite
 1 - Hairstyle
 2 - Weapon
 3 - Head bottom
 4 - Head top
 5 - Head mid
 6 - Hair color
 7 - Clothes color
 8 - Shield
 9 - Shoes

Whatever 'shoes' means is anyone's guess, ask Gravity - the client does nothing 
with this value. It still wants it from the server though, so it is kept, but 
normally doesn't do a thing.
 
Only the look data for hairstyle, hair color and clothes color are saved to the 
char server's database and will persist. The rest freely change as the character 
puts on and removes equipment, changes maps, logs in and out and otherwise you 
should not expect to set them. In fact, messing with them is generally 
hazardous, do it at your own risk, it is not tested what will this actually do -
it won't cause database corruption and probably won't cause a server crash, but 
it's easy to crash the client with just about anything unusual.

However, it might be an easy way to quickly check for empty view IDs for 
sprites, which is essential for making custom headgear. 

Since a lot of people have different palettes for hair and clothes, it's 
impossible to tell you what all the color numbers are. If you want a serious 
example, there is a Stylist script inside the default rAthena installation that 
you can look at: 'npc/custom/stylist.txt'

---------------------------------------

*pushpc <direction>,<cells>;

This command will push the currently attached player to given direction by given
amount of square cells. Direction is the same as used when declaring NPCs, and
can be specified by using one of the DIR_* constants (db/const.txt).

The knock-back is not restricted by items or map flags, only obstacles are taken
into account. If there is not enough space to perform the push (e.g. due to a
wall), the character is pushed only up to the obstacle.

    // pushes the character 5 cells in 3 o'clock direction from its
    // current position.
    pushpc DIR_EAST, 5;

---------------------------------------

*get_revision()

This command will return the SVN revision number that the server is currently
running on.

    if ( get_revision() >= 15000 )
        mes "Welcome to rAthena!";

---------------------------------------

*get_githash()

This command will return the Git Hash that the server is currently running on.

	mes "Welcome to rAthena! Git Hash: " + get_githash();

---------------------------------------
\\
4,1.- Item-related commands
\\
---------------------------------------

*getitem <item id>,<amount>{,<account ID>};
*getitem "<item name>",<amount>{,<account ID>};

This command will give an amount of specified items to the invoking character. 
If an optional account ID is specified, and the target character is currently 
online, items will be created in their inventory instead. If they are not 
online, nothing will happen.

In the first and most commonly used version of this command, items are 
referred to by their database ID number found inside 'db/(pre-)re/item_db.txt'.

    getitem 502,10 // The person will receive 10 apples
    getitem 617,1  // The person will receive 1 Old Violet Box

This transaction is logged if the log script generated transactions option is 
enabled.

You may also create an item by its name in the 'english name' field in the 
item database:

    getitem "RED_POTION",10;

Which will do what you'd expect. If it can't find that name in the database, 
apples will be created anyway. It is often a VERY GOOD IDEA to use it like this.

This is used in pretty much all NPC scripts that have to do with items and 
quite a few item scripts. For more examples check just about any official script.

---------------------------------------

*getitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*getitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

This command will give an amount of specified items to the invoking character. 
If an optional account ID is specified, and the target character is currently 
online, items will be created in their inventory instead. If they are not 
online, nothing will happen. It works essentially the same as 'getitem' but is
a lot more flexible.

Those parameters that are different from 'getitem' are:

identify    - Whether you want the item to be identified (1) or not (0).
refine      - For how many pluses will it be refined.
              It will not let you refine an item higher than the max refine.
attribute   - Whether the item is broken (1) or not (0).
card1,2,3,4 - If you want a card compound to it, place the card ID number into 
              the specific card slot.

Card1-card4 values are also used to store name information for named items, as 
well as the elemental property of weapons and armor. You can create a named item 
in this manner, however, if you just need a named piece of standard equipment, 
it is much easier to the 'getnameditem' function instead.

You will need to keep these values if you want to destroy and then perfectly 
recreate a named item, for this see 'getinventorylist'.

If you still want to try creating a named item with this command because 
'getnameditem' won't do it for you cause it's too limited, you can do it like 
this. Careful, minor magic ahead.

    // First, let's get an ID of a character who's name will be on the item.
    // Only an existing character's name may be there.
    // Let's assume our character is 'Adam' and find his ID.
    @charid = getcharid(0,"Adam");

    // Now we split the character ID number into two portions with a binary
    // shift operation. If you don't understand what this does, just copy it.
    @card3 = @charid & 65535;
    @card4 = @charid >> 16;

    // If you're inscribing non-equipment, @card1 must be 254.
    // Arrows are also not equipment. :)
    @card1 = 254;

    // For named equipment, card2 means the Star Crumbs and elemental 
    // crystals used to make this equipment. For everything else, it's 0.
    @card2 = 0;

    // Now, let's give the character who invoked the script some 
    // Adam's Apples:
    getitem2 512,1,1,0,0,@card1,@card2,@card3,@card4;

This wasn't tested with all possible items, so I can't give any promises, 
experiment first before relying on it.

To create equipment, continue this example it like this:

    // We've already have card3 and card4 loaded with correct
    // values so we'll just set up card1 and card2 with data
    // for an Ice Stiletto.

    // If you're inscribing equipment, @card1 must be 255.
    @card1 = 255;

    // That's the number of star crumbs in a weapon.
    @sc = 2;

    // That's the number of elemental property of the weapon.
    @ele = 1;

    // And that's the wacky formula that makes them into
    // a single number.    
    @card2 = @ele+((@sc*5)<<8);

    // That will make us an Adam's +2 VVS Ice Stiletto:
    getitem2 1216,1,1,2,0,@card1,@card2,@card3,@card4;

Experiment with the number of star crumbs - I'm not certain just how much will 
work most and what it depends on. The valid element numbers are:

 1 - Ice, 2 - Earth 3 - Fire 4 - Wind.

You can, apparently, even create duplicates of the same pet egg with this 
command, creating a pet which is the same, but simultaneously exists in two 
eggs, and may hatch from either, although, I'm not sure what kind of a mess will 
this really cause.

---------------------------------------

*getitembound <item id>,<amount>,<bound type>{,<account ID>};
*getitembound "<item name>",<amount>,<bound type>{,<account ID>};

This command behaves identically to 'getitem', but the items created will be
bound to the target character as specified by the bound type. All items created
in this manner cannot be dropped, sold, vended, auctioned, or mailed, and in
some cases cannot be traded or stored.

Valid bound types are:
 Bound_Account : Account Bound item
 Bound_Guild   : Guild Bound item
 Bound_Party   : Party Bound item
 Bound_Char    : Character Bound item

---------------------------------------

*getitembound2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>{,<account ID>};
*getitembound2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>{,<account ID>};

This command behaves identically to 'getitem2', but the items created will be
bound to the target character as specified by the bound type. All items created
in this manner cannot be dropped, sold, vended, auctioned, or mailed, and in
some cases cannot be traded or stored.

For a list of bound types see 'getitembound'.

---------------------------------------

*getnameditem <item id>,<character name|character ID>;
*getnameditem "<item name>",<character name|character ID>;

Create an item signed with the given character's name. 

The command returns 1 when the item is created successfully, or 0 if it fails.
Failure occurs when:
- There is no player attached.
- Item name or ID is not valid.
- The given character ID/name is offline.

Example:

//This will give the currently attached player a Aaron's Apple (if Aaron is online).
	getnameditem "Apple","Aaron";
	
//Self-explanatory (I hope).
	if (getnameitem("Apple","Aaron")) {
		mes "You now have a Aaron's Apple!";
	}

---------------------------------------

*rentitem <item id>,<time>;
*rentitem "<item name>",<time>;

Creates a rental item in the attached character's inventory. The item will expire 
in <time> seconds and be automatically deleted. When receiving a rental item, 
the character will receive a message in their chat window. The character will 
also receive warning messages in their chat window before the item disappears.

This command can not be used to rent stackable items. Rental items cannot be 
dropped, traded, sold to NPCs, or placed in guild storage. (i.e. trade mask 75)
Note: 'delitem' in an NPC script can still remove rental items.

---------------------------------------

*rentitem2 <item id>,<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;
*rentitem2 "<item name>",<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;

Creates a rental item in the attached character's inventory. The item will expire 
in <time> seconds and be automatically deleted. See 'rentitem' for further details.

See 'getitem2' for an explanation of the expanded parameters.

---------------------------------------

*makeitem <item id>,<amount>,"<map name>",<X>,<Y>;
*makeitem "<item name>",<amount>,"<map name>",<X>,<Y>;

This command will create an item on the specified cell of a map.

As with any dropped items, the items created with this command will disappear after
a period of time. Using an amount greater than 1 will create a single stack of the
given amount, not multiple stacks of 1.

Like 'getitem', it also accepts an 'english name' field from the database and creates
Apples if the name isn't found.
If the map name is given as "this", the map the invoking character is on will be used.

---------------------------------------

*makeitem2 <item id>,<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;
*makeitem2 "<item name>",<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;

This command will create an item on the specified cell of a map. See 'makeitem' for
further details.

See 'getitem2' for an explanation of the expanded parameters.

---------------------------------------

*cleanarea "<map name>",<x1>,<y1>,<x2>,<y2>;
*cleanmap "<map name>";

These commands will clear all items lying on the ground on the specified map, either
within the x1/y1-x2/y2 rectangle or across the entire map.

---------------------------------------

*searchitem <array name>,"<item name>";

This command will fill the given array with the ID of items whose name matches
the given one. It returns the number of items found. For performance reasons,
the results array is limited to 10 items.

	mes "What item are you looking for?";
	input .@name$;
	.@qty = searchitem(.@matches[0],.@name$);
	mes "I found " + .@qty + " items:";
	for (.@i = 0; .@i < .@qty; .@i++)
		// Display name (eg: "Apple[0]")
		mes getitemname(.@matches[.@i]) + "[" + getitemslots(.@matches[.@i]) + "]";

---------------------------------------

*delitem <item id>,<amount>{,<account ID>};
*delitem "<item name>",<amount>{,<account ID>};

This command will remove a specified amount of items from the invoking/target character. 
Like all the item commands, it uses the item ID found inside 'db/(pre-)re/item_db.txt'.

    delitem 502,10; // The person will lose 10 apples
    delitem 617,1;  // The person will lose 1 Old Violet Box

It is always a good idea to check if the player actually has the items before you delete them.
If you try to delete more items that the player has, the player will lose the ones he/she has 
and the script will terminate with an error.

Like 'getitem', this command will also accept an 'english name' field from the 
database. If the name is not found, nothing will be deleted.

---------------------------------------

*cartdelitem <item id>,<amount>{,<account ID>};
*cartdelitem "<item name>",<amount>{,<account ID>};
*storagedelitem <item id>,<amount>{,<account ID>};
*storagedelitem "<item name>",<amount>{,<account ID>};

This command behaves identically to 'delitem', but deletes items from the player's
cart or storage. If no cart is mounted, 'cartdelitem' will fail.

---------------------------------------

*delitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*delitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

This command will remove a specified amount of items from the invoking/target character. 
See 'getitem2' for an explanation of the expanded parameters.

---------------------------------------

*cartdelitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*cartdelitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*storagedelitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*storagedelitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};

This command behaves identically to 'delitem2', but deletes items from the player's
cart or storage. If no cart is mounted, 'cartdelitem2' will fail.

---------------------------------------

*countitem(<item id>)
*countitem("<item name>")

This function will return the number of items for the specified item ID that the 
invoking character has in the inventory.

    mes "[Item Checker]";
    mes "Hmmm, it seems you have "+countitem(502)+" apples";
    close;

Like 'getitem', this function will also accept an 'english name' from the 
database as an argument.

If you want to state the number at the end of a sentence, you can do it by 
adding up strings:

    mes "[Item Checker]";
    mes "Hmmm, the total number of apples you are holding is "+countitem("APPLE");
    close;
    
---------------------------------------

*cartcountitem(<item id>)
*cartcountitem("<item name>")
*storagecountitem(<item id>)
*storagecountitem("<item name>")

This command behaves identically to 'countitem', but counts items from the player's
cart or storage. If no cart is mounted, 'cartcountitem' will return -1.

---------------------------------------

*countitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)
*countitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)

Expanded version of 'countitem' function, used for created/carded/forged items.

This function will return the number of items for the specified item ID and
other parameters that the invoking character has in the inventory.
See 'getitem2' for an explanation of the expanded parameters.

---------------------------------------

*cartcountitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)
*cartcountitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)
*storagecountitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)
*storagecountitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>)

This command behaves identically to 'countitem2', but counts items from the player's
cart or storage. If no cart is mounted, 'cartcountitem2' will return -1.

---------------------------------------

*countbound({<bound type>})

This function will return the number of bounded items in the character's
inventory, and sets an array @bound_items[] containing all item IDs of the
counted items. If a bound type is specified, only those items will be counted.

For a list of bound types see 'getitembound'.

Example:
	mes "You currently have "+countbound()+" bounded items.";
	next;
	mes "The list of bounded items include:";
	for(.@i = 0; .@i < getarraysize(@bound_items); .@i++)
		mes getitemname(@bound_items[.@i]);
	close;

---------------------------------------

*groupranditem <group id>{,<sub_group>};

Returns the item_id of a random item picked from the group specified. The
different groups and their group number are specified in 'db/(pre-)re/item_group_db.txt'.

When used in conjunction with other functions, you can get a random item. For
example, for a random pet lure:

getitem groupranditem(15),1;

'sub_group' is used to get the available random items of item group from specified random
group. More info, just like the explanation below.

---------------------------------------

*getrandgroupitem <group id>,<quantity>{,<sub_group>};

Similar to the above example, this command allows players to obtain the specified
quantity of a random item from the group "<group id>". The different groups and 
their group number are specified in db/(pre-)re/item_group_db.txt

For example, obtaining three of the same random item from Old Blue Box:

getrandgroupitem(1,3);
getrandgroupitem(IG_BlueBox,3); //see const.txt at 'Item Group ID' section

If quantity is 0, and if the item(s) at specified IG_ has defined amount, the amount of
the item that will be obtained, will according to the amount on that IG_ data.

By default, if getrandgroupitem is used to get random item from IG_ which has more than
defined random group, it always read random group 1, other item that as random item at
random group > 2 never been touched. Use 'sub_group' to choose which random group will be
obtained.

Example:

	IG_ExGetGroupItem,Coat,2,2,1
	IG_ExGetGroupItem,Muffler,2,3,1
	IG_ExGetGroupItem,Yggdrasilberry,10,7,1

	IG_ExGetGroupItem,Yggdrasilberry,10,7,2
	IG_ExGetGroupItem,Seed_Of_Yggdrasil,5,15,2

	1. 'getrandgroupitem(IG_ExGetGroupItem,1)'
	   Player has chance to get 1x Coat or 1x Muffler or 1x Yggdrasilberry. Player never
	   has chance to get Seed_of_Yggdrasil because it is in different random group.

	2. 'getrandgroupitem(IG_ExGetGroupItem,0)'
	   Player has chance to get 2x Coat or 3x Muffler or 7x Yggdrasilberry. Player never
	   has chance to get Seed_of_Yggdrasil because it is in different random group.

	3. 'getrandgroupitem(IG_ExGetGroupItem,0,2)'
	   Player has chance to get 10x Yggdrasilberry or 15x Seed_of_Yggdrasil. Player never
	   has chance to get Coat, Muffler, and Seed_of_Yggdrasil because it is in different
	   random group. 

---------------------------------------

*getgroupitem <group_id>;

Gives item(s) to the attached player based on item group contents.
This is not working like 'getrandgroupitem' which only give 1 item for specified
item group.

For contants, see the "Item Group ID" section in 'db/const.txt'.

---------------------------------------

*enable_items;
*disable_items;

These commands toggle the ability to change equipment while interacting with
an NPC. To avoid possible exploits, the commands affect the particular script
instance only. Note that if a different script also calls enable_items, it
will override the last call (so you may want to call this command at the start
of your script without assuming it is still in effect).

The default setting, 'item_enabled_npc', is defined in 'conf/battle/items.conf'.

---------------------------------------

*itemskill <skill id>,<skill level>;
*itemskill "<skill name>",<skill level>;

This command is meant for item scripts to replicate single-use skills in usable
items. It will not work properly if there is a visible dialog window or menu.
If the skill is self or auto-targeting, it will be used immediately; otherwise a
target cursor is shown.

// When Anodyne is used, it will cast Endure (8), Level 1, as if the actual
// skill has been used from skill tree.
605,Anodyne,Anodyne,11,2000,0,100,,,,,10477567,2,,,,,{ itemskill 8,1; },{}

---------------------------------------

*consumeitem <item id>;
*consumeitem "<item name>";

This command will run the item script of the specified item on the invoking
character. The character does not need to possess the item, and the item will
not be deleted. While this command is intended for usable items, it will run
for any item type.

This command does not currently work with the 'itemskill' script command.

---------------------------------------

*produce <item level>;

This command will open a crafting window on the client connected to the invoking 
character. The 'item level' is a number which determines what kind of a crafting 
window will pop-up.

You can see the full list of such item levels in 'db/produce_db.txt' which determines 
what can actually be produced. The window will not be empty only if the invoking 
character can actually produce the items of that type and has the appropriate raw
materials in their inventory.

The success rate to produce the item is the same as the success rate of the skill
associated with the item level. If there is no skill id, the success rate will be 50%.

Valid item levels are:

 1   - Level 1 Weapons
 2   - Level 2 Weapons
 3   - Level 3 Weapons
 21  - Blacksmith's Stones and Metals
 22  - Alchemist's Potions, Holy Water, Assassin Cross's Deadly Poison
 23  - Elemental Converters

---------------------------------------

*cooking <dish level>;

This command will open a produce window on the client connected to the invoking 
character. The 'dish level' is the number which determines what kind of dish
level you can produce. You can see the full list of dishes that can be produced in 
'db/produce_db.txt'.

The window will be shown empty if the invoking character does not have enough of
the required incredients to cook a dish.

Valid dish levels are:

11 - Level 1 Dish
12 - Level 2 Dish
13 - Level 3 Dish
14 - Level 4 Dish
15 - Level 5 Dish
16 - Level 6 Dish
17 - Level 7 Dish
18 - Level 8 Dish
19 - Level 9 Dish
20 - Level 10 Dish

Although it's required to set a dish level, it doesn't matter if you set it to 1
and you want to cook a level 10 dish, as long as you got the required incredients
to cook the dish the command works.

---------------------------------------

*makerune <% success bonus>;

This command will open a rune crafting window on the client connected to the
invoking character. Since this command is officially used in rune ores, a bonus
success rate must be specified (which adds to the base formula).

You can see the full list of runes that can be produced in 'db/produce_db.txt'.
The window will not be empty only if the invoking character can actually produce
a rune and has the appropriate raw materials in their inventory.

---------------------------------------

*successremovecards <equipment slot>;

This command will remove all cards from the item found in the specified 
equipment slot of the invoking character, create new card items and give them to 
the character. If any cards were removed in this manner, it will also show a 
success effect.

---------------------------------------

*failedremovecards <equipment slot>,<type>;

This command will remove all cards from the item found in the specified 
equipment slot of the invoking character. 'type' determines what happens to the 
item and the cards:

 0 - will destroy both the item and the cards.
 1 - will keep the item, but destroy the cards.
 2 - will keep the cards, but destroy the item.
  
Whatever the type is, it will also show a failure effect on screen.

---------------------------------------

*repair <broken item number>;

This command repairs a broken piece of equipment, using the same list of broken 
items as available through 'getbrokenid'.

---------------------------------------

*repairall;

This command repairs all broken equipment in the attached player's inventory.
A repair effect will be shown if any items are repaired, else the command will
end silently.

---------------------------------------

*successrefitem <equipment slot>{,<count>};

This command will refine an item in the specified equipment slot of the invoking 
character by +1, or a count if given. For a list of equipment slots see 'getequipid'.
This command will also display a 'refine success' effect on the character and put
appropriate messages into their chat window. It will also give the character fame
points if a weapon reached +10 this way, even though these will only take effect for
blacksmith who will later forge a weapon.

---------------------------------------

*failedrefitem <equipment slot>;

This command will fail to refine an item in the specified equipment slot of the 
invoking character. The item will be destroyed. This will also display a 'refine 
failure' effect on the character and put appropriate messages into their chat 
window.

---------------------------------------

*downrefitem <equipment slot>{,<count>};

This command will downgrade an item in the specified equipment slot of the invoking
character by -1, or a count if given. For a list of equipment slots see 'getequipid'.
This command will also display a 'refine failure' effect on the character and put 
appropriate messages into their chat window.

---------------------------------------

*unequip <equipment slot>;

This command will unequip whatever is currently equipped in the invoking 
character's specified equipment slot. For a full list of possible equipment 
slots see 'getequipid'.

If an item occupies several equipment slots, it will get unequipped from all of 
them.

---------------------------------------

*delequip <equipment slot>;

This command will destroy whatever is currently equipped in the invoking
character's specified equipment slot. For a full list of possible equipment 
slots see 'getequipid'.

This command will return 1 if an item was deleted and 0 otherwise.

---------------------------------------

*breakequip <equipment slot>;

This command will break and unequip whatever is currently equipped in the
invoking character's specified equipment slot. For a full list of possible
equipment slots see 'getequipid'.

This command will return 1 if an item was broken and 0 otherwise.

---------------------------------------

*clearitem;

This command will destroy all items the invoking character has in their 
inventory (including equipped items). It will not affect anything else, like 
storage or cart.

---------------------------------------

*equip <item id>;
*autoequip <item id>,<option>;

These commands are to equip a equipment on the attached character. 
The equip function will equip the item ID given when the player has
this item in his/her inventory, while the autoequip function will 
equip the given item ID when this is looted. The option parameter of
the autoequip is 1 or 0, 1 to turn it on, and 0 to turn it off.

Examples:

//This will equip a 1104 (falchion) on the character if this is in the inventory.
	equip 1104;
	
//The invoked character will now automatically equip a falchion when it's looted.
	autoequip 1104,1;
	
//The invoked character will no longer automatically equip a falchion.
	autoequip 1104,0;

---------------------------------------

*buyingstore <slots>;

Invokes buying store preparation window like the skill 'Open Buying Store',
without the item requirement. Amount of slots is limited by the server to
a maximum of 5 slots by default.

Example:
	// Gives the player opportunity to buy 4 different kinds of items.
	buyingstore 4;

---------------------------------------

*searchstores <uses>,<effect>;

Invokes the store search window, which allows to search for both vending
and buying stores. Parameter uses indicates, how many searches can be
started, before the window has to be reopened. Effect value affects,
what happens, when a result item is double-clicked and can be one of the
following:

	0 = Shows the store's position on the mini-map and highlights the
	    shop sign with yellow color, when the store is on same map
	    as the invoking player.
	1 = Directly opens the shop, regardless of distance.

Example:
	// Item Universal_Catalog_Gold (10 uses, effect: open shop)
	searchstores 10,1;

---------------------------------------

*enable_command;
*disable_command;

These commands toggle the ability to use atcommand while interacting with an NPC.

The default setting, 'atcommand_enable_npc', is defined in 'conf/battle/gm.conf'.

---------------------------------------
//
4,1.- End of item-related commands
//
---------------------------------------

*openstorage;

This will open character's Kafra storage window on the client connected to the
invoking character. It can be used from any kind of NPC or item script, not just
limited to Kafra Staff.

The storage window opens regardless of whether there are open NPC dialogs or
not, but it is preferred to close the dialog before displaying the storage
window, to avoid any disruption when both windows overlap.

    mes "Close this window to open your storage.";
    close2;
    openstorage;
    end;

---------------------------------------

*openmail;

This will open a character's Mail window on the client connected to the 
invoking character.

    mes "Close this window to open your mail inbox.";
    close2;
    openmail;
    end;

---------------------------------------

*openauction;

This will open the Auction window on the client connected to the invoking character.

    mes "Close this window to open the Auction window.";
    close2;
    openauction;
    end;

---------------------------------------
\\
4,2.- Guild-related commands
\\
---------------------------------------

*guildopenstorage()

This function works the same as 'openstorage' but will open a guild storage 
window instead for the guild storage of the guild the invoking character belongs 
to. This is a function because it returns a value - 0 if the guild storage was 
opened successfully and 1 if it wasn't. (Notice, it's a ZERO upon success.) 
Since guild storage is only accessible to one character at one time, it may fail 
if another character is accessing the guild storage at the same time.

This will also fail and return 2 if the character does not belong to any guild.

---------------------------------------

*guildchangegm(<guild id>,<new master's name>)

This function will change the Guild Master of a guild. The ID is the guild's
id, and the new guild master's name must be passed.

Returns 1 on success, 0 otherwise.

---------------------------------------

*guildgetexp <amount>;

This will give the specified amount of guild experience points to the guild the 
invoking character belongs to. It will silently fail if they do not belong to 
any guild.

---------------------------------------

*guildskill <skill id>,<level>
*guildskill "<skill name>",<level>

This command will bump up the specified guild skill by the specified number of 
levels. This refers to the invoking character and will only work if the invoking 
character is a member of a guild AND its guild master, otherwise no failure 
message will be given and no error will occur, but nothing will happen - same 
about the guild skill trying to exceed the possible maximum. The full list of 
guild skills is available in 'db/(pre-)re/skill_db.txt', these are all the GD_ skills at 
the end.

// This would give your character's guild one level of Approval (GD_APPROVAL ID 
// 10000). Notice that if you try to add two levels of Approval, or add
// Approval when the guild already has it, it will only have one level of 
// Approval afterwards.
    guildskill 10000,1,0;

You might want to make a quest for getting a certain guild skill, make it hard 
enough that all the guild needs to help or something. Doing this for the Glory 
of the Guild skill, which allows your guild to use an emblem, is a good idea for 
a fun quest. (Wasting a level point on that is really annoying :D)

---------------------------------------
//
4,2 End of guild-related commands.
//
---------------------------------------

*resetlvl <action type>;

This is a character reset command, meant mostly for rebirth script supporting 
Advanced jobs, which will reset the invoking character's stats and level 
depending on the action type given. Valid action types are:

 1 - Base level 1, Job level 1, 0 skill points, 0 base exp, 0 job exp, wipes the 
     status effects (only the ones settable by 'setoption'), sets all stats to 1. 
     If the new job is 'Novice High', give 100 status points, give First Aid and 
     Play Dead skills.
 2 - Base level 1, Job level 1, 0 skill points, 0 base exp, 0 job exp. 
     Skills and attribute values are not altered.
 3 - Base level 1, base exp 0. Nothing else is changed.
 4 - Job level 1, job exp 0. Nothing else is changed.

In all cases everything the character has on will be unequipped.

Even though it doesn't return a value, it is used as a function in the official 
rebirth scripts. Ask AppleGirl why.

---------------------------------------

*resetstatus;

This is a character reset command, which will reset the stats on the invoking 
character and give back all the stat points used to raise them previously. 
Nothing will happen to any other numbers about the character.

Used in reset NPC's (duh!)

---------------------------------------

*resetskill;

This command takes off all the skill points on the invoking character, so they 
only have Basic Skill blanked out (lvl 0) left, and returns the points for them 
to spend again. Nothing else will change but the skills. Quest skills will also 
reset if 'quest_skill_reset' option is set to Yes in 'battle_athena.conf'. If 
the 'quest_skill_learn' option is set in there, the points in the quest skills 
will also count towards the total.

Used in reset NPC's (duh!)

---------------------------------------

*sc_start 	<effect type>,<ticks>,<value 1>{,<rate>,<flag>{,<GID>}};
*sc_start2 	<effect type>,<ticks>,<value 1>,<value 2>{,<rate>,<flag>{,<GID>}};
*sc_start4 	<effect type>,<ticks>,<value 1>,<value 2>,<value 3>,<value 4>{,<rate>,<flag>{,<GID>}};
*sc_end 	<effect type>{,<GID>};

These commands will bestow a status effect on a character.

The <effect type> determines which status is invoked. This can be either a number
or constant, with the common statuses (mostly negative) found in 'db/const.txt'
with the 'SC_' prefix. A full list is located in 'src/map/status.h', though
they are not currently documented.

The duration of the status is given in <ticks>, or milleseconds.

Certain status changes take an additional parameter <value 1>, which typically
modifies player stats by the given number or percentage. This differs for each
status, and is sometimes zero.

Optional value <rate> is the chance that the status will be invoked (100 = 1%).
This is used primarily in item scripts. When used in an NPC script, a flag MUST
be defined for the rate to work.

Optional value <flag> is how the status change start will be handled (a bitmask).
 1: Status change cannot be avoided.
 2: Tick cannot be reduced by stats (default).
 4: sc_data loaded, so no value will be altered.
 8: Rate cannot be reduced.

If a <GID> is given, the status change will be invoked on the specified character
instead of the one attached to the script. This can only be defined after setting
a rate and flag.

'sc_start2' and 'sc_start4' allow extra parameters to be passed, and are used only
for effects that require them. The meaning of the extra values vary depending on the
effect type.

'sc_end' will remove a specified status effect. If SC_ALL (-1) is given, it will
perform a complete removal of all statuses (although permanent ones will re-apply).

Examples:
	// This will poison the invoking character for 10 minutes at 50% chance.
	sc_start SC_POISON,600000,0,5000;

	// This will bestow the effect of Level 10 Blessing.
	sc_start 10,240000,10;

	// Elemental armor defense takes the following four values:
	// val1 is the first element, val2 is the resistance to the element val1.
	// val3 is the second element, val4 is the resistance to the element val3.
	sc_start4 SC_DefEle,60000,Ele_Fire,20,Ele_Water,-15;

	// This will end the Freezing status for the invoking character.
	sc_end SC_FREEZE;

Note: to use SC_NOCHAT you should alter Manner
	set Manner, -5;	// Will mute a user for 5 minutes
	set Manner, 0;	// Will unmute a user
	set Manner, 5;	// Will unmute a user and prevent the next use of 'Manner'

---------------------------------------

*getstatus(<effect type>{,<type>})

Retrieve information about a specific status effect when called. Depending on <type>
specified the function will return different information.

Possible <type> values:
	- 0 or undefined: whether the status is active
	- 1: the val1 of the status
	- 2: the val2 of the status
	- 3: the val3 of the status
	- 4: the val4 of the status
	- 5: the amount of time in milliseconds that the status has remaining

If <type> is not defined or is set to 0, then the script function will either
return 1 if the status is active, or 0 if the status is not active. If the status
is not active when any of the <type> fields are provided, this script function
will always return 0.

---------------------------------------

*skilleffect <skill id>,<number>;
*skilleffect "<skill name>",<number>;

This command displays visual and aural effects of given skill on currently
attached character. The number parameter is for skill whose visual effect
involves displaying of a number (healing or damaging). Note, that this command
will not actually use the skill, it is intended for scripts, which simulate
skill usage by the NPC, such as buffs, by setting appropriate status and
displaying the skill's effect.

    mes "Be blessed!";
    // Heal of 2000 HP
    heal 2000,0;
    skilleffect 28,2000;
    // Blessing Level 10
    sc_start 10,240000,10;
    skilleffect 34,0;
    // Increase AGI Level 5
    sc_start 12,140000,5;
    skilleffect 29,0;

This will heal the character with 2000 HP, buff it with Blessing Lv 10 and
Increase AGI Lv 5, and display appropriate effects.

---------------------------------------

*npcskilleffect <skill id>,<number>,<x>,<y>;
*npcskilleffect "<skill name>",<number>,<x>,<y>;

This command behaves identically to 'skilleffect', however, the effect will not 
be centered on the invoking character's sprite, nor on the NPC sprite, if any, 
but will be centered at map coordinates given on the same map as the invoking 
character.

---------------------------------------

*specialeffect <effect number>{,<send_target>{,"<NPC Name>"}};

This command will display special effect with the given number, centered on the 
specified NPCs coordinates, if any. For a full list of special effect numbers 
known see 'doc/effect_list.txt'. Some effect numbers are known not to work in 
some client releases. (Notably, rain is absent from any client executables 
released after April 2005.)

<NPC name> parameter will display <effect number> on another NPC. If the NPC
specified does not exist, the command will do nothing. When specifying an NPC,
<send_target> must be specified when specifying an <NPC Name>, specifying AREA 
will retain the default behavior of the command.

	// this will make the NPC "John Doe#1"
	// show the effect "EF_HIT1" specified by
	// Jane Doe. I wonder what John did...
	mes "[Jane Doe]";
	mes "Well, I never!";
	specialeffect EF_HIT1,AREA,"John Doe#1";
	close;

---------------------------------------

*specialeffect2 <effect number>{,<send_target>{,"<Player Name>"}};

This command behaves identically to 'specialeffect', but the effect will be
centered on the invoking character's sprite.

<Player name> parameter will display <effect number> on another Player than the
one currently attached to the script. Like with specialeffect, when specifying
a player, <send_target> must be supplied, specifying AREA will retain the default 
behavior of the command.

---------------------------------------

*statusup <stat>;

This command will bump a specified stat of the invoking character up by one 
permanently. Stats are to be given as number, but you can use these constants to 
replace them:

bStr -  Strength
bVit -  Vitality
bInt -  Intelligence
bAgi -  Agility
bDex -  Dexterity
bLuk -  Luck

---------------------------------------

*statusup2 <stat>,<amount>;

This command will bump a specified stat of the invoking character up by the 
specified amount permanently. The amount can be negative. See 'statusup'.

// This will decrease a character's Vit forever.
    statusup bVit,-1;

---------------------------------------

*bonus <bonus type>,<val1>;
*bonus2 <bonus type>,<val1>,<val2>;
*bonus3 <bonus type>,<val1>,<val2>,<val3>;
*bonus4 <bonus type>,<val1>,<val2>,<val3>,<val4>;
*bonus5 <bonus type>,<val1>,<val2>,<val3>,<val4>,<val5>;

These commands are meant to be used in item scripts. They will probably work 
outside item scripts, but the bonus will not persist for long. They, as 
expected, refer only to an invoking character.

You can find the full list of possible bonuses and which command to use for each 
kind in 'doc/item_bonus.txt'.

---------------------------------------

*autobonus <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus2 <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus3 <bonus script>,<rate>,<duration>,<skill id>,{<other script>};
*autobonus3 <bonus script>,<rate>,<duration>,"<skill name>",{<other script>};

These commands are meant to be used in item scripts. They will probably work 
outside item scripts, but the bonus will not persist for long. They, as 
expected, refer only to an invoking character.

What these commands do is 'attach' a script to the player which will get
executed on attack (or when attacked in the case of autobonus2).

Rate is the trigger rate of the script (10000 = 100%). 

Duration is the time that the bonus will last for since the script has triggered.

Skill ID/skill name the skill which will be used as trigger to start the bonus. (autobonus3)

The optional argument 'flag' is used to classify the type of attack where the script
can trigger (it shares the same flags as the bAutoSpell bonus script):

Range criteria:
	BF_SHORT:  Trigger on melee attack
	BF_LONG:   Trigger on ranged attack
	Default:   BF_SHORT+BF_LONG
Attack type criteria:
	BF_WEAPON: Trigger on weapon skills 
	BF_MAGIC:  Trigger on magic skills 
	BF_MISC:   Trigger on misc skills
	Default:   BF_WEAPON
Skill criteria:
	BF_NORMAL: Trigger on normal attacks
	BF_SKILL:  Trigger on skills
	default:   If the attack type is BF_WEAPON (only) BF_NORMAL is used,
		   otherwise BF_SKILL+BF_NORMAL is used.

The difference between the optional argument 'other script' and the 'bonus script' is that,
the former one triggers only when attacking(or attacked) and the latter one runs on 
status calculation as well, which makes sure, within the duration, the "bonus" that get
lost on status calculation is restored. So, 'bonus script' is technically supposed to accept
"bonus" command only. And we usually use 'other script' to show visual effects.

In all cases, when the script triggers, the attached player will be the one
who holds the bonus. There is currently no way of knowing within this script  
who was the other character (the attacker in autobonus2, or the target in
autobonus and autobonus3).

//Grants a 1% chance of starting the state "all stats +10" for 10 seconds when
//using weapon or misc attacks (both melee and ranged skills) and shows a special 
//effect when the bonus is active.
	autobonus "{ bonus bAllStats,10; }",10,10000,BF_WEAPON|BF_MISC,"{ specialeffect2 EF_FIRESPLASHHIT; }";

---------------------------------------

*bonus_script "<script code>",<duration>{,<flag>{,<type>{,<status_icon>{,<char_id>}}}};

This command will attach a script to a player for a given duration, in seconds.
After that time, the script will automatically expire. The same bonus cannot be
stacked. By default, this bonus will be stored on `bonus_script` table when player
logs out.

Note that the maximum number of 'bonus_script' commands that can run simultaneously
for a player is 10 (MAX_PC_BONUS_SCRIPT in 'src/map/pc.h').

Flags (bitmask):
	1   : Remove when dead.
	2   : Removable by Dispell.
	4   : Removable by Clearance.
	8   : Remove when player logs out.
	16  : Removeable by Banishing Buster.
	32  : Removable by Refresh.
	128 : Removable by Luxanima.
	256 : Remove when Madogear is activated or deactivated.
	512 : Remove when receive damage.
	1024: Script is permanent, cannot be cleared by bonus_script_clear

Types:
	This will be used to decide negative or positive buff for 'debuff_on_logout'.
	0: Ignore the buff type and won't be removed if the flag is not &8 (Default)
	1: Buff
	2: Debuff

Status_icon: See "Status Icon" section in 'db/const.txt'. Default is SI_BLANK (-1).

Example:
	// Apple gives you +5 Str bonus for 1 minute when it's consumed.
	512,Apple,Apple,0,15,,20,,,,,0xFFFFFFFF,63,2,,,,,,{ bonus_script "{ bonus bStr,5; }",60; },{},{}

---------------------------------------

*bonus_script_clear {<flag>,{<char_id>}};

Removes atatched bonus_script from player. If no 'char_id' given, it will removes
from the invoker.

If 'flag' is 1, means will clears all scripts even it's Permanent effect. By default,
it just removes non-permanent script.

---------------------------------------

*skill <skill id>,<level>{,<flag>};
*skill "<skill name>",<level>{,<flag>};
*addtoskill <skill id>,<level>{,<flag>};
*addtoskill "<skill name>",<level>{,<flag>};

These commands will give the invoking character a specified skill. This is also 
used for item scripts.

Level is obvious. Skill id is the ID number of the skill in question as per 
'db/(pre-)re/skill_db.txt'. It is not known for certain whether this can be used to give 
a character a monster's skill, but you're welcome to try with the numbers given 
in 'db/(pre-)re/mob_skill_db.txt'.

Flag is 0 if the skill is given permanently (will get written with the character 
data) or 1 if it is temporary (will be lost eventually, this is meant for card 
item scripts usage.).  The flag parameter is optional, and defaults to 1 in 
'skill' and to 2 in 'addtoskill'.

Flag 2 means that the level parameter is to be interpreted as a stackable 
additional bonus to the skill level. If the character did not have that skill 
previously, they will now at 0+the level given.

Flag 4 is the same as flag 1 in that it saves to the database.  However, these skills
are ignored when any action is taken that adjusts the skill tree (reset/job change).

// This will permanently give the character Stone Throw (TF_THROWSTONE,152), at 
// level 1.
    skill 152,1,0;

---------------------------------------

*nude;

This command will unequip anything equipped on the invoking character.

It is not required to do this when changing jobs since 'jobchange' will unequip 
everything not equippable by the new job class anyway.

---------------------------------------

*sit {"<character name>"};
*stand {"<character name>"};

These commands will make a character sit or stand.
If no character is specified, the command will run for the invoking character.

---------------------------------------

*disguise <Monster ID>;
*undisguise;

This command disguises the current player with a monster sprite.
The disguise lasts until 'undisguise' is issued or the player logs out.

Example:

disguise 1002; // Disguise character as a Poring.
next;
undisguise; // Return to normal character sprite.

---------------------------------------

*transform <monster name/ID>,<duration>,<sc type>{,<val1>,<val2>,<val3>,<val4>};

This command will turn a player into a monster for a given duration and grants an
SC attribute effect while transformed. Note that players cannot be transformed
during War of Emperium or if already disguised.

---------------------------------------
\\
4,3 Marriage-related commands
\\
---------------------------------------

*marriage("<spouse name>");

This function will marry two characters, the invoking character and the one 
referred to by name given, together, setting them up as each other's marriage 
partner. No second function call has to be issued (in current SVN at least) to 
make sure the marriage works both ways. The function returns 1 upon success, or 
0 if the marriage could not be completed, either because the other character 
wasn't found or because one of the two characters is already married.

This will do nothing else for the marriage except setting up the spouse ID for 
both of these characters. No rings will be given and no effects will be shown.

---------------------------------------

*wedding;

This command will call up wedding effects - the music and confetti - centered on 
the invoking character. Example can be found in the wedding script.

---------------------------------------

*divorce()

This function will "un-marry" the invoking character from whoever they were 
married to. Both will no longer be each other's marriage partner, (at least in 
current SVN, which prevents the cases of multi-spouse problems). It will return 
1 upon success or 0 if the character was not married at all.

This function will also destroy both wedding rings and send a message to both 
players, telling them they are now divorced.

---------------------------------------
//
4,3.- End of marriage-related commands
//
---------------------------------------

*pcfollow <id>,<target id>;
*pcstopfollow <id>;

Makes a character follow or stop following someone. This command does the same
as the @follow command. The main difference is that @follow can use character
names, and this commands needs the account ID for the target.

Examples:
	// This will make Aaron follow Bullah, when both of these characters are online.
	pcfollow getCharID(3,"Aaron"),getCharID(3,"Bullah");

	// Makes Aaron stop following whoever he is following.
	pcstopfollow getCharID(3,"Aaron");
	
---------------------------------------

*pcblockmove <id>,<option>;

Prevents the given GID from moving when the option is 1, and enables the ID to
move again when the option is 0. This command will run for the attached player
if the given GID is zero.

Examples:
	// Prevents the current char from moving away.
	pcblockmove getcharid(3),1;

	// Enables the current char to move again.
	pcblockmove getcharid(3),0;

--------------------------------------- 

==================================
|5.- Mob / NPC -related commands.|
==================================
---------------------------------------

*monster     "<map name>",<x>,<y>,"<name to show>",<mob id>,<amount>{,"<event label>",<size>,<ai>};
*areamonster "<map name>",<x1>,<y1>,<x2>,<y2>,"<name to show>",<mob id>,<amount>{,"<event label>",<size>,<ai>};

This command will spawn a monster on the specified coordinates on the specified 
map. If the script is invoked by a character, a special map name, "this", will 
be recognized to mean the name of the map the invoking character is located at. 
This command works fine in the item scripts.

The same command arguments mean the same things as described above in the 
beginning of this document when talking about permanent monster spawns. Monsters 
spawned in this manner will not respawn upon being killed.

Unlike the permanent monster spawns, if the mob id is -1, a random monster will 
be picked from the entire database according to the rules configured in the 
server for dead branches. This will work for all other kinds of non-permanent 
monster spawns.

The only very special thing about this command is an event label, which is an 
optional parameter. This label is written like '<NPC object name>::<label name>' 
and upon the monster being killed, it will execute the script inside of the 
specified NPC object starting from the label given. The RID of the player 
attached at this execution will be the RID of the killing character.

<size> can be:
	0 = medium (default)
	1 = small
	2 = big
	
<ai> can be:
	0 = none (default)
	1 = attack/friendly
	2 = sphere (Alchemist skill)
	3 = flora (Alchemist skill)
	4 = zanzou (Kagerou/Oboro skill)

    monster "place",60,100,"Poring",1002,1,"NPCNAME::OnLabel";

The coordinates of 0,0 will spawn the monster on a random place on the map.

The 'areamonster' command works much like the 'monster' command and is not 
significantly different, but spawns the monsters within a square defined by 
x1/y1-x2/y2.

Simple monster killing script:

        <Normal NPC object definition. Let's assume you called him NPCNAME.>
        mes "[Summon Man]";
        mes "Want to start the Poring hunt?";
        next;
        if(select("Yes.:No.") == 2) {
                mes "[Summon Man]";
                mes "Come back later.";
                close;
        }

        // Summon 10 Porings.
        // Using coordinates 0,0 will spawn them in a random location.
        monster "prontera",0,0,"Quest Poring",1002,10,"NPCNAME::OnPoringKilled";

        mes "[Summon Man]";
        mes "Now go and kill all the Porings I summoned.";
        close;

    OnPoringKilled:
        $PoringKilled++;
        if ($PoringKilled >= 10) goto L_AllDead;
        end;

    L_AllDead:
        announce "Summon Man: Well done. All the Porings are dead!",3;
        $PoringKilled = 0;
        end;

For more good examples see just about any official 2-1 or 2-2 job quest script.

---------------------------------------

*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,<skill id>,<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;
*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,"<skill name>",<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;

This command will make all monsters of the specified mob ID in the specified 
area use the specified skill. Map name, x, and y define the center of the area, 
which extending <range> cells in each direction (ex: a range of 3 would create 
a 7x7 square). The skill can be specified by skill ID or name. <cast time> is in 
milliseconds (1000 = 1 second), and the rest should be self-explanatory. 

<target type> can be: 
	0 = self
	1 = the mob's current target
	2 = the mob's master
	3 = random target

Example:

	// spawn 1 Shining Plant in the 5x5 area centered on (155,188)
	areamonster "prontera",153,186,157,190,"Shining Plant",1083,1;
	// make the plant cast level 10 Cold Bolt on a random target
	areamobuseskill "prontera",155,188,2,1083,"MG_COLDBOLT",10,3000,1,e_gg,3;

---------------------------------------

*killmonster "<map name>","<event label>"{,<type>};

This command will kill all monsters that were spawned with 'monster' or 
'addmonster' and have a specified event label attached to them. Commonly used to 
get rid of remaining quest monsters once the quest is complete.

If the label is given as "All", all monsters which have their respawn times set 
to -1 (like all the monsters summoned with 'monster' or 'areamonster' script 
command, and all monsters summoned with GM commands, but no other ones - that 
is, all non-permanent monsters) on the specified map will be killed regardless 
of the event label value.

As of r12876 killmonster now supports an optional argument type. Using 1 for type
will make the command fire "OnMyMobDead" events from any monsters that do die
as a result of this command.

---------------------------------------

*killmonsterall "<map name>"{,<type>};

This command will kill all monsters on a specified map name, regardless of how 
they were spawned or what they are. As of r12873, The behavior has changed slightly.
In light of a label behavior fix for mob spawning commands that will now allow the label to 
trigger when there is no player, killmonsterall has also been modified to support this.

Using this the normal/old way means labels don't trigger when a player didn't
attack/kill a monster. This is because it breaks compatibility with older scripts if
forced to use the new method. However, if you wish to use the new label type with this
command, simply use 1 for type. Any other number won't be recognized.

---------------------------------------

*strmobinfo(<type>,<monster id>);

This function will return information about a monster record in the database, as 
per 'db/(pre-)re/mob_db.txt'. Type is the kind of information returned. Valid types are:
It will return 0 if there is no such monster (or the type value is invalid),
or an empty string if you requested the monster's name.

 1 - 'english name' field in the database, a string.
 2 - 'japanese name' field in the database, a string.
     All other returned values are numbers:
 3 - Level.
 4 - Maximum HP.
 5 - Maximum SP.
 6 - Experience reward.
 7 - Job experience reward.

---------------------------------------

*mobcount("<map name>","<event label>")

This function will count all the monsters on the specified map that have a given 
event label and return the number or 0 if it can't find any. Naturally, only 
monsters spawned with 'monster' and 'areamonster' script commands can have non-empty 
event label.
If you pass this function an empty string for the event label, it will return 
the total count of monster without event label, including permanently spawning monsters.
With the dynamic mobs system enabled, where mobs are not kept 
in memory for maps with no actual people playing on them, this will return a 0 
for any such map.
If the event label is given as "all", all monsters will be counted, regardless of
having any event label attached.

If the map name is given as "this", the map the invoking character is on will 
be used. If the map is not found, or the invoker is not a character while the map 
is "this", it will return -1.

---------------------------------------

*clone "<map name>",<x>,<y>,"<event>",<char id>{,<master_id>{,<mode>{,<flag>,<duration>}}}

This command creates a monster which is a copy of another player. The first
four arguments serve the same purpose as in the monster script command, The
<char id> is the character id of the player to clone (player must be online).
If <master id> is given, the clone will be a 'slave/minion' of it. Master_id
must be a character id of another online player.

The mode can be specified to determine the behavior of the clone. Its
values are the same as the ones used for the mode field in the mob_db. The
default mode is aggressive, assists, can move, can attack.

Flag can be either zero or one currently. If zero, the clone is a normal
monster that'll target players, if one, it is considered a summoned monster,
and as such, it'll target other monsters. Defaults to zero.

The duration specifies how long the clone will live before it is auto-removed.
Specified in seconds, defaults to no limit (zero).

Returned value is the monster ID of the spawned clone. If command fails,
returned value is zero.

---------------------------------------

*summon "monster name",<monster id>{,<Time Out>{,"event label"}};

This command will summon a monster. (see also 'monster') Unlike monsters spawned
with other commands, this one will set up the monster to fight to protect the
invoking character. Monster name and mob id obey the same rules as the one given
at the beginning of this document for permanent monster spawns with the
exceptions mentioned when describing 'monster' command.

The effect for the skill 'Call Homunculus' will be displayed centered on the
invoking character.

Timeout is the time in milliseconds the summon lives, and is set default 
to 60000 (1 minute). Note that also the value 0 will set the timer to default,
and it is not possible to create a spawn that lasts forever.
If an event label is given, upon the monster being killed, the event label will
run as if by 'donpcevent'.

// Will summon a dead branch-style monster to fight for the character.
summon "--ja--",-1;

---------------------------------------

*addmonsterdrop <monster id>,<item id>,<rate>;
*addmonsterdrop "<monster name>",<item id>,<rate>;
*delmonsterdrop <monster id>,<item id>;
*delmonsterdrop "<monster name>",<item id>;

These commands will temporarily add or delete a monster drop, which will be reset
when the mob database reloads or the server shuts down. They return 1 upon success.

If the monster already drops the specified item, its drop rate will be updated with
the given rate (100 = 1%).

Examples:
	// Makes Owl Baron drop Honey at an 80% rate.
	addmonsterdrop 1295,518,8000;

	// Deletes Executioner's Mitten from Rybio.
	delmonsterdrop 1201,7017;

---------------------------------------

*disablenpc "<NPC object name>";
*enablenpc "<NPC object name>";

These two commands will disable and enable, respectively, an NPC object 
specified by name. The disabled NPC will disappear from sight and will no longer 
be triggerable in the normal way. It is not clear whether it will still be 
accessible through 'donpcevent' and other triggering commands, but it probably 
will be. You can disable even warp NPCs if you know their object names, which is 
an easy way to make a map only accessible through walking half the time. Then 
you 'enablenpc' them back.

You can also use these commands to create the illusion of an NPC switching 
between several locations, which is often better than actually moving the NPC -
create one NPC object with a visible and a hidden part to their name, make a few 
copies, and then disable all except one.

---------------------------------------

*hideonnpc "<NPC object name>";
*hideoffnpc "<NPC object name>";

These commands will make the NPC object specified display as hidden/visible, 
even though not actually disabled per se. Hidden as in thief Hide skill, but 
unfortunately, not detectable by Ruwach or Sight.

As they are now, these commands are pointless, it is suggested to use 
'disablenpc'/'enablenpc', because these two commands actually unload the NPC 
sprite location and other accompanying data from memory when it is not used.
However, you can use these for some quest ideas (such as cloaking NPCs talking 
while hidden then revealing.... you can wonder around =P

---------------------------------------

*doevent "<NPC object name>::<event label>";

This command will start a new execution thread in a specified NPC object at the 
specified label. The execution of the script running this command will not stop,
and the event called by the 'doevent' command will not run until the invoking
script has terminated. No parameters may be passed with a doevent call.

The script of the NPC object invoked in this manner will run as if it's been 
invoked by the RID that was active in the script that issued a 'doevent'. As
such, the command will not work if an RID is not attached.

    place,100,100,1%TAB%script%TAB%NPC%TAB%53,{
        mes "This is what you will see when you click me";
        close;
    OnLabel:
        mes "This is what you will see if the doevent is activated";
        close;
    }

    ....

    doevent "NPC::OnLabel";

---------------------------------------

*donpcevent "<NPC object name>::<event label>";

This command invokes the event label code within an another NPC or NPCs. It
starts a separate instance of execution, and the invoking NPC will resume
execution its immediately.

If the supplied event label has the form "NpcName::OnLabel", then only given
NPC's event label will be invoked (much like 'goto' into another NPC). If the
form is "::OnLabel" (NPC name omitted), the event code of all NPCs with given
label will be invoked, one after another. In both cases the invoked script
will run without an attached RID, whether or not the invoking script was
attached to a player. The event label name is required to start with "On".

This command can be used to make other NPCs act, as if they were responding to
the invoking NPC's actions, such as using an emotion or talking.

    place,100,100,1%TAB%script%TAB%NPC1%TAB%53,{
        mes "NPC2 copies my actions!";
        close2;
        donpcevent "NPC2::OnEmote";
    OnEmote:
        emotion rand(1,30);
        end;
    }

    place,102,100,1%TAB%script%TAB%NPC2%TAB%53,{
        mes "NPC1 copies my actions!";
        close2;
        donpcevent "NPC1::OnEmote";
    OnEmote:
        emotion rand(1,30);
        end;
    }

Whichever of the both NPCs is talked to, both will show a random emotion at the
same time. 

As of r16564, command now returns 1 or 0 on success and failure.
A debug message also shows on the console when no events are triggered.

---------------------------------------

*cmdothernpc "<npc name>","<command>";

This is simply "donpcevent <npc name>::OnCommand<command>".
It is an approximation of official server script language's 'cmdothernpc'.

---------------------------------------

*npctalk "<message>";

This command will display a message to the surrounding area as if the NPC object 
running it was a player talking - that is, above their head and in the chat 
window. The display name of the NPC will get appended in front of the message to 
complete the effect.

    // This will make everyone in the area see the NPC greet the character
    // who just invoked it.
    npctalk "Hello "+strcharinfo(0)+", how are you?";

---------------------------------------

*setnpcdisplay("<npc name>", "<display name>", <class id>, <size>)
*setnpcdisplay("<npc name>", "<display name>", <class id>)
*setnpcdisplay("<npc name>", "<display name>")
*setnpcdisplay("<npc name>", <class id>)

Changes the display name and/or display class of the target NPC.
Returns 0 is successful, 1 if the NPC does not exist.
Size is 0 = normal 1 = small 2 = big.

---------------------------------------
\\
5,1.- Time-related commands
\\
---------------------------------------

*addtimer <ticks>,"NPC::OnLabel";
*deltimer "NPC::OnLabel";
*addtimercount <ticks>,"NPC::OnLabel";

These commands will create, destroy, and delay a countdown timer - 'addtimer' to
create, 'deltimer' to destroy and 'addtimercount' to delay it by the specified
number of ticks. For all three cases, the event label given is the identifier of
that timer. The timer runs on the character object that is attached to the script,
and can have multiple instances. When the label is run, it is run as if the player that
the timer runs on has clicked the NPC.

When this timer runs out, a new execution thread will start in the specified NPC
object at the specified label.

The ticks are given in 1/1000ths of a second.

One more thing. These timers are stored as part of player data. If the player
logs out, all of these get immediately deleted, without executing the script.
If this behavior is undesirable, use some other timer mechanism (like 'sleep').

Example:
<NPC Header> {
	dispbottom "Starting a 5 second timer...";
	addtimer 5000, strnpcinfo(3)+"::On5secs";
	end;
On5secs:
	dispbottom "5 seconds have passed!";
	end;
}

---------------------------------------

*initnpctimer{ "<NPC name>" {, <Attach Flag>} } |
             { "<NPC name>" | <Attach Flag> };
*stopnpctimer{ "<NPC name>" {, <Detach Flag>}  } |
             { "<NPC name>" | <Detach Flag> };
*startnpctimer{ "<NPC name>" {, <Attach Flag>} } |
              { "<NPC name>" | <Attach Flag> };
*setnpctimer <tick>{,"<NPC name>"};
*getnpctimer(<type of information>{,"<NPC name>"})
*attachnpctimer {"<character name>"};
*detachnpctimer {"<NPC name>"};

This set of commands and functions will create and manage an NPC-based timer.
The NPC name may be omitted, in which case the calling NPC is used as target.

Contrary to addtimer/deltimer commands which let you have many different timers
referencing different labels in the same NPC, each with their own countdown,
'initnpctimer' can only have one per NPC object. But it can trigger many labels
and let you know how many were triggered already and how many still remain.

This timer is counting up from 0 in ticks of 1/1000ths of a second each. Upon 
creating this timer, the execution will not stop, but will happily continue 
onward. The timer will then invoke new execution threads at labels 
"OnTimer<time>:" in the NPC object it is attached to. 

To create the timer, use the 'initnpctimer', which will start it running. 
'stopnpctimer' will pause the timer, without clearing the current tick, while 
'startnpctimer' will let the paused timer continue.

By default timers do not have a RID attached, which lets them continue even
if the player that started them logs off. To attach a RID to a timer, you can
either use the optional "attach flag" when using 'initnpctimer/startnpctimer', 
or do it manually by using 'attachnpctimer'. Likewise, the optional flag of
stopnpctimer lets you detach any RID after stopping the timer, and by using
'detachnpctimer' you can detach a RID at any time.

Normally there is only a single timer per NPC, but as an exception, as long as
you attach a player to the timer, you can have multiple timers running at once,
because these will get stored on the players instead of the NPC.
NOTE: You need to attach the RID before the timer _before_ you start it to
get a player-attached timer. Otherwise it'll stay a NPC timer (no effect).

If the player that is attached to the npctimer logs out, the "OnTimerQuit:"
event label of that NPC will be triggered, so you can do the appropriate
cleanup (the player is still attached when this event is triggered).

The 'setnpctimer' command will explicitly set the timer to a given tick.
'getnpctimer' provides timer information. Its parameter defines what type:

 0 - Will return the current tick count of the timer.
 1 - Will return 1 if there are remaining "OnTimer<ticks>:" labels in the 
     specified NPC waiting for execution.
 2 - Will return the number of times the timer has triggered and will trigger
     an "OnTimer<tick>:"  label in the specified NPC.

Example 1:

    <NPC Header> {
        // We need to use attachnpctimer because the mes command below needs RID attach
        attachnpctimer;
        initnpctimer;
        npctalk "I cant talk right now, give me 10 seconds";
        end;
    OnTimer5000:
        npctalk "Ok 5 seconds more";
        end;
    OnTimer6000:
        npctalk "4";
        end;
    OnTimer7000:
        npctalk "3";
        end;
    OnTimer8000:
        npctalk "2";
        end;
    OnTimer9000:
        npctalk "1";
        end;
    OnTimer10000:
        stopnpctimer;
        mes "[Man]";
        mes "Ok we can talk now";
        detachnpctimer;
        // and remember attachnpctimer and detachnpctimer can only use while the NPC timer is not running !
    }

Example 2:

    OnTimer15000:
        npctalk "Another 15 seconds have passed.";

        // You have to use 'initnpctimer' instead of 'setnpctimer 0'.
        // This is equal to 'setnpctimer 0' + 'startnpctimer'.
        // Alternatively, you can also insert another 'OnTimer15001' label so that the timer won't stop. */
        initnpctimer;
        end;
       
    // This OnInit label will run when the script is loaded, so that the timer 
    // is initialized immediately as the server starts. It is dropped back to 0 
    // every time the NPC says something, so it will cycle continuously.
    OnInit:
        initnpctimer;
        end;

Example 3:

    mes "[Man]";
    mes "I have been waiting "+(getnpctimer(0)/1000)+" seconds for you.";
    // We divide the timer returned by 1000 to convert milliseconds to seconds.
    close;

Example 4:

    mes "[Man]";
    mes "Ok, I will let you have 30 more seconds...";
    close2;
    setnpctimer (getnpctimer(0)-30000);
    // Notice the 'close2'. If there were a 'next' there the timer would be 
    // changed only after the player pressed the 'next' button.
    end;
 
---------------------------------------
 
*sleep {<milliseconds>};
*sleep2 {<milliseconds>};
*awake "<NPC name>";

These commands are used to control the pause of a NPC.
sleep and sleep2 will pause the script for the given amount of milliseconds.
Awake is used to cancel a sleep. When awake is called on a NPC it will run as
if the sleep timer ran out, and thus making the script continue. Sleep and sleep2
basically do the same, but the main difference is that sleep will not keep the rid,
while sleep2 does.

Examples:
	sleep 10000; //pause the script for 10 seconds and ditch the RID (so no player is attached anymore)
	sleep2 5000; //pause the script for 5 seconds, and continue with the RID attached.
	awake "NPC"; //Cancels any running sleep timers on the NPC 'NPC'.

---------------------------------------

*progressbar "<color>",<seconds>;

This command works almost like sleep2, but displays a progress bar
above the head of the currently attached character (like cast bar).
Once the given amount of seconds passes, the script resumes. If the
character moves while the progress bar progresses, it is aborted and
the script ends. The color format is in RGB (0xRRGGBB). The color is
currently ignored by the client and appears always green.

---------------------------------------
//
5,1.- End of time-related commands
//
---------------------------------------

*announce "<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}};

This command will broadcast a message to all or most players, similar to 
@kami/@kamib GM commands.

    announce "This will be shown to everyone at all in yellow.",0;

The region the broadcast is heard in (target), source of the broadcast
and the color the message will come up as is determined by the flags.

The flag values are coded as constants in 'db/const.txt' to make them easier to use.

Target flags:
- bc_all: Broadcast message is sent server-wide (default).
- bc_map: Message is sent to everyone in the same map as the source of the broadcast (see below).
- bc_area: Message is sent to players in the vicinity of the source.
- bc_self: Message is sent only to current player.
You cannot use more than one target flag.

Source flags:
- bc_pc: Broadcast source is the attached player (default).
- bc_npc: Broadcast source is the NPC, not the player attached to the script
  (useful when a player is not attached or the message should be sent to those
  nearby the NPC).
You cannot use more than one source flag.

Special flags:
- bc_yellow: Broadcast will be displayed in yellow color (default).
- bc_blue: Broadcast will be displayed in blue color.
- bc_woe: Indicates that this broadcast is 'WoE Information' that can be disabled client-side.
Due to the way client handles broadcasts, it is impossible to set both bc_blue and bc_woe.

The optional parameters allow usage of broadcasts in custom colors, font-weights, sizes etc.
If any of the optional parameters is used, special flag is ignored.
Optional parameters may not work well (or at all) depending on a game client used.

The color parameter is a single number which can be in hexadecimal notation.
For example:
    announce "This will be shown to everyone at all in green.",bc_all,0x00FF00;
Will display a global announce in green. The color format is in RGB (0xRRGGBB).

In official scripts only two font-weights (types) are used:
 - normal (FW_NORMAL = 400, default),
 - bold (FW_BOLD = 700).

Default font size is 12.

Using this for private messages to players is probably not that good an idea,
but it can be used instead in NPCs to "preview" an announce.

    // This will be a private message to the player using the NPC that made the 
    // announcement
    announce "This is my message just for you",bc_blue|bc_self;

    // This will be shown on everyones screen that is in sight of the NPC.
    announce "This is my message just for you people here",bc_npc|bc_area;

---------------------------------------

*mapannounce "<map name>","<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};

This command will work like 'announce' but will only broadcast to characters 
currently residing on the specified map. The flag and optional parameters
parameters are the same as in 'announce', but target and source flags are ignored.

---------------------------------------

*areaannounce "<map name>",<x1>,<y1>,<x2>,<y2>,"<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};

This command works like 'announce' but will only broadcast to characters 
residing in the specified x1/y1-x2/y2 rectangle on the map given. The flags and
optional parameters are the same as in 'announce', but target and source flags are ignored.

    areaannounce "prt_church",0,0,350,350,"God's in his heaven, all right with the world",0;

---------------------------------------

*callshop "<name>",<option>;

These are a series of commands used to create dynamic shops. 
The 'callshop' function calls an invisible shop (view -1) as if the player clicked on it.

The options are:
	0 = The normal window (buy, sell and cancel)
	1 = The buy window
	2 = The sell window

A shop called with this command will trigger the labels "OnBuyItem" and "OnSellItem"
(as long as an npcshop* command is executed from that NPC, see note below). These
labels, if used, will replace how the shop handles the buying and selling of items,
allowing for the creation of dynamic shops.

The label "OnBuyItem" sets the following arrays:
	@bought_nameid   - item ID bought
	@bought_quantity - amount bought

The label "OnSellItem" sets the following arrays:
	@sold_nameid     - item ID sold
	@sold_quantity   - amount sold
	@sold_refine     - refine count
	@sold_attribute  - if the item is broken (1) or not (0)
	@sold_identify   - if the item is identified (1) or not (0)
	@sold_card1      - card slot 1
	@sold_card2      - card slot 2
	@sold_card3      - card slot 3
	@sold_card4      - card slot 4

Note: These labels will only be triggered if an npcshop* command is executed because these
commands set a special data on the shop NPC, named master_nd in the source. The above labels
are triggered in the NPC whose master_nd is given in the shop.

A full example of a dynamic shop can be found in doc/sample/npc_dynamic_shop.txt.

---------------------------------------

*npcshopitem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}};

This command lets you override the contents of an existing NPC shop or cashshop. The
current sell list will be wiped, and only the items specified with the price
specified will be for sale.

The function returns 1 if shop was updated successfully, or 0 if not found.

Note that you cannot use -1 to specify default selling price!

---------------------------------------

*npcshopadditem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}};

This command will add more items at the end of the selling list for the
specified NPC shop or cashshop. If you specify an item already for sell, that item will
appear twice on the sell list.

The function returns 1 if shop was updated successfully, or 0 if not found.

Note that you cannot use -1 to specify default selling price!

---------------------------------------

*npcshopdelitem "<name>",<item id>{,<item id>{,<item id>{,...}}};

This command will remove items from the specified NPC shop or cashshop.
If the item to remove exists more than once on the shop, all instances will be
removed.

Note that the function returns 1 even if no items were removed. The return
value is only to confirm that the shop was indeed found.

---------------------------------------

*npcshopattach "<name>"{,<flag>};

This command will attach the current script to the given NPC shop.
When a script is attached to a shop, the events "OnBuyItem" and "OnSellItem"
of your script will be executed whenever a player buys/sells from the shop.
Additionally, the arrays @bought_nameid[], @bought_quantity[] or @sold_nameid[]
and @sold_quantity[] will be filled up with the items and quantities
bought/sold.

The optional parameter specifies whether to attach ("1") or detach ("0") from
the shop (the default is to attach). Note that detaching will detach any NPC
attached to the shop, even if it's from another script, while attaching will
override any other script that may be already attached.

The function returns 0 if the shop was not found, 1 otherwise.

---------------------------------------

*waitingroom "<chatroom name>",<limit>{,"<event label>"{,<trigger>{,<required zeny>{,<min lvl>{,<max lvl>}}}}};

This command will create a chat room, owned by the NPC object running this 
script and displayed above the NPC sprite.
The maximum length of a chat room name is 60 letters.

The limit is the maximum number of people allowed to enter the chat room.
The attached NPC is included in this count. If the optional event and trigger
parameters are given, the event label ("<NPC object name>::<label name>")
will be invoked as if with a 'doevent' upon the number of people in the chat
room reaching the given triggering amount.

// The NPC will just show a box above its head that says "Hello World", clicking 
// it will do nothing, since the limit is zero.
    waitingroom "Hello World",0;

// The NPC will have a box above its head, it will say "Disco - Waiting Room" 
// and will have 8 waiting slots. Clicking this will enter the chat room, where 
// the player will be able to wait until 7 players accumulate. Once this happens, 
// it will cause the NPC "Bouncer" run the label "OnStart".

    waitingroom "Disco - Waiting Room",8,"Bouncer::OnStart",7;

// The NPC will have a box above its head, it will say "Party - Waiting Room" 
// and will have 8 waiting slots. Clicking this will allow a player who has
// 5000 zeny and lvl 50~99 to enter the chat room, where the player will be
// able to wait until 7 players accumulate. Once this happens, it will cause
// the NPC "Bouncer" run the label "OnStart".

    waitingroom "Party - Waiting Room",8,"Bouncer::OnStart",7,5000,50,99;

Creating a waiting room does not stop the execution of the script and it will 
continue to the next line.

For more examples see the 2-1 and 2-2 job quest scripts which make extensive use 
of waiting rooms.

---------------------------------------

*delwaitingroom {"<NPC object name"};

This command will delete a waiting room. If no parameter is given, it will 
delete a waiting room attached to the NPC object running this command, if it is, 
it will delete a waiting room owned by another NPC object. This is the only way 
to get rid of a waiting room, nothing else will cause it to disappear.

It's not clear what happens to a waiting room if the NPC is disabled with 
'disablenpc', by the way.

---------------------------------------

*enablewaitingroomevent {"<NPC object name>"};
*disablewaitingroomevent {"<NPC object name>"};
*enablearena;
*disablearena;

This will enable and disable triggering the waiting room event (see 
'waitingroom') respectively. Optionally giving an NPC object name will do that 
for a specified NPC object. The chat room will not disappear when triggering is 
disabled and enabled in this manner and players will not be kicked out of it.
Enabling a chat room event will also cause it to immediately check whether the 
number of users in it exceeded the trigger amount and trigger the event 
accordingly.

Normally, whenever a waiting room was created to make sure that only one 
character is, for example, trying to pass a job quest trial, and no other 
characters are present in the room to mess up the script.

The 'enablearena'/'disablearena' commands are just aliases with no parameter.
These are supposedly left here for compatibility with official server scripts,
but no rAthena script uses these at the moment.

---------------------------------------

*getwaitingroomstate(<information type>{,"<NPC object name>"})

This function will return information about the waiting room state for the 
attached waiting room or for a waiting room attached to the specified NPC if 
any.

The valid information types are:

 0  - Number of users currently chatting.
 1  - Maximum number of users allowed.
 2  - Will return 1 if the waiting room has a trigger set.
      0 otherwise.
 3  - Will return 1 if the waiting room is currently disabled.
      0 otherwise.
 4  - The Title of the waiting room (string)
 5  - Password of the waiting room, if any. Pointless, since there is no way to 
      set a password on a waiting room right now.
 16 - Event name of the waiting room (string)
 32 - Whether or not the waiting room is full.
 33 - Whether the amount of users in the waiting room is higher than the trigger 
      number.

---------------------------------------

*warpwaitingpc "<map name>",<x>,<y>{,<number of people>};

This command will warp the amount of characters equal to the trigger number of 
the waiting room chat attached to the NPC object running this command to the 
specified map and coordinates, kicking them out of the chat. Those waiting the 
longest will get warped first. It can also do a random warp on the same map 
("Random" instead of map name) and warp to the save point ("SavePoint").

The list of characters to warp is taken from the list of the chat room members. 
Those not in the chat room will not be considered even if they are talking to 
the NPC in question. If the number of people is given, exactly this much people 
will be warped.

This command can also keep track of who just got warped. It does this by setting 
special variables:

$@warpwaitingpc[] is an array containing the account_id numbers of the 
                  characters who were just warped.
$@warpwaitingpcnum contains the number of the character it just warped.

See also 'getpartymember' for advice on what to do with those variables.

The obvious way of using this effectively would be to set up a waiting room for 
two characters to be warped onto a random PVP map for a one-on-one duel, for 
example.

---------------------------------------

*kickwaitingroomall {"<NPC object name>"};

This command kicks everybody out of a specified waiting room chat.

---------------------------------------

*setmapflagnosave "<map name>","<alternate map name>",<x>,<y>;

This command sets the 'nosave' flag for the specified map and also gives an 
alternate respawn-upon-relogin point.

It does not make a map impossible to make a save point on as you would normally 
think, 'savepoint' will still work. It will, however, make the specified map 
kick the reconnecting players off to the alternate map given to the coordinates 
specified.

---------------------------------------

*setmapflag "<map name>",<flag>{,<zone>{,<type>}};

This command marks a specified map with the given map flag, which will alter the 
behavior of the map. A full list of mapflags is located in 'db/const.txt' with
the 'mf_' prefix, and documentation can be found in 'doc/mapflags.txt'.

The map flags alter the behavior of the map regarding teleporting (mf_nomemo, 
mf_noteleport, mf_nowarp, mf_nogo), storing location when disconnected 
(mf_nosave), dead branch usage (mf_nobranch), penalties upon death 
(mf_nopenalty, mf_nozenypenalty), PVP behavior (mf_pvp, mf_pvp_noparty, 
mf_pvp_noguild), WoE behavior (mf_gvg,mf_gvg_noparty), ability to use 
skills or open up trade deals (mf_notrade, mf_novending, mf_noskill, mf_noicewall),
current weather effects (mf_snow, mf_fog, mf_sakura, mf_leaves, mf_rain, mf_clouds, 
mf_fireworks) and whether night will be in effect on this map (mf_nightenabled).

The optional parameter 'zone' is used to set the zone for restricted mapflags.

For the 'skill_damage' mapflag, 'zone' functions as 'value' (-100 to 100000) and
'type' can be:
 1: damage against players
 2: damage against mobs
 3: damage against bosses
 4: damage against other
 5: caster type

---------------------------------------

*removemapflag "<map name>",<flag>{,<zone>};

This command removes a mapflag from a specified map. 
See 'setmapflag' for a list of mapflags.

The optional parameter 'zone' is used to remove the zone from restricted mapflags.

---------------------------------------

*getmapflag("<map name>",<flag>{,<type>})

This command checks the status of a given mapflag and returns the mapflag's state. 
0 means OFF, and 1 means ON. See 'setmapflag' for a list of mapflags.

The optional parameter 'type' is used in the 'skill_damage' mapflag:
 0: if mapflag is set (default)
 1: damage against players
 2: damage against mobs
 3: damage against bosses
 4: damage against other
 5: caster type

---------------------------------------

*setbattleflag "<battle flag>",<value>;
*getbattleflag("<battle flag>")

Sets or gets the value of the given battle flag.
Battle flags are the flags found in the battle/*.conf files and is also used in Lupus' variable rates script.

Examples:

// Will set the base experience rate to 20x (2000%)
	setBattleFlag "base_exp_rate",2000;
	
// Will return the value of the base experience rate (when used after the above example, it would print 2000).
	mes getBattleFlag("base_exp_rate");

---------------------------------------

*warpportal <source x>,<source y>,"<map name>",<target x>,<target y>;

Creates a warp portal identical to the Acolyte "Warp Portal" skill.
The source coordinates specify the portal's location on the map of the invoking NPC.
The target map and coordinates determine the destination of the portal.

Examples:

// Will create a warp portal on the NPC's map at 150,150 leading to prontera, coords 150,180.
	warpportal 150,150,"prontera",150,180;

---------------------------------------

*mapwarp "<from map>","<to map>",<x>,<y>{,<type>,<ID>};

This command will collect all characters located on the From map and warp them 
wholesale to the same point on the To map, or randomly distribute them there if 
the coordinates are zero. "Random" is understood as a special To map name and 
will mean randomly shuffling everyone on the same map.

Optionally, a type and ID can be specified. Available types are:

 0 - Everyone
 1 - Guild
 2 - Party

Example:

// Will warp all members of guild with ID 63 on map prontera to map alberta.
	mapwarp "prontera","alberta",150,150,1,63;

---------------------------------------
\\
5,2.- Guild-related commands
\\
---------------------------------------

*maprespawnguildid "<map name>",<guild id>,<flag>;

This command goes through the specified map and for each player and monster 
found there does stuff.

Flag is a bit-mask (add up numbers to get effects you want)
 1 - warp all guild members to their save points.
 2 - warp all non-guild members (including guildless players) to their save points.
 4 - remove all monsters which are not guardian or Emperium.

Flag 7 will, therefore, mean 'wipe all mobs but guardians and the Emperium and 
kick all characters out', which is what the official scripts do upon castle 
surrender. Upon start of WoE, the scripts do 2 (warp all intruders out).

For examples, check the WoE scripts in the distribution.

---------------------------------------

*agitstart;
*agitend;
*agitstart2;
*agitend2;

These four commands will start and end War of Emperium or War of Emperium SE.

This is a bit more complex than it sounds, since the commands themselves won't 
actually do anything interesting, except causing all 'OnAgitStart:' and 
'OnAgitEnd:', or 'OnAgitStart2:' and 'OnAgitEnd2:' in the case of latter two
commands, events to run everywhere, respectively. They are used as  simple 
triggers to run a lot of complex scripts all across the server, and they, 
in turn, are triggered by clock with an 'OnClock<time>:' time-triggering label.

---------------------------------------

*gvgon "<map name>";
*gvgoff "<map name>";

These commands will turn GVG mode for the specified maps on and off, setting up 
appropriate map flags. In GVG mode, maps behave as if during the time of WoE, 
even though WoE itself may or may not actually be in effect. 

---------------------------------------

*flagemblem <guild id>;

This command only works when run by the NPC objects which have sprite id 722, 
which is a 3D guild flag sprite. If it isn't, the data will change, but nothing 
will be seen by anyone. If it is invoked in that manner, the emblem of the 
specified guild will appear on the flag, though, if any players are watching it 
at this moment, they will not see the emblem change until they move out of sight 
of the flag and return.

This is commonly used in official guildwar scripts with a function call which 
returns a guild id:

// This will change the emblem on the flag to that of the guild that owns
// "guildcastle"

    flagemblem GetCastleData("guildcastle",1);

---------------------------------------

*guardian "<map name>",<x>,<y>,"<name to show>",<mob id>{,"<event label>"{,<guardian index>}};

This command is roughly equivalent to 'monster', but is meant to be used with 
castle guardian monsters and will only work with them. It will set the guardian 
characteristics up according to the castle's investment values and otherwise 
set the things up that only castle guardians need.

Since trunk r12524:
Returns the id of the mob or 0 if an error occurred.
When 'guardian index' isn't supplied it produces a temporary guardian.
Temporary guardians are not saved with the castle and can't be accessed by guardianinfo.

---------------------------------------

*guardianinfo("<map name>", <guardian number>, <type>);

This function will return various info about the specified guardian, or -1
if it fails for some reason. It is primarily used in the castle manager NPC.

Map name and guardian number (value between 0 and 7) define the target.
Type indicates what information to return:
 0 - visibility (whether the guardian is installed or not)
 1 - max. hp
 2 - current hp

---------------------------------------
//
5,2.- End of guild-related commands
//
---------------------------------------

*npcspeed <speed value>;
*npcwalkto <x>,<y>;
*npcstop;

These commands will make the NPC object in question move around the map. As they 
currently are, they are a bit buggy and are not useful for much more than making 
an NPC move randomly around the map.

'npcspeed' will set the NPCs walking speed to a specified value. As in the 
@speed GM command, 200 is the slowest possible speed while 0 is the fastest 
possible (instant motion). 100 is the default character walking speed.

'npcwalkto' will start the NPC sprite moving towards the specified coordinates 
on the same map it is currently on. The script proceeds immediately after the
NPC begins moving.

'npcstop' will stop the motion.

While in transit, the NPC will be clickable, but invoking it will cause it to 
stop moving, which will make its coordinates different from what the client 
computed based on the speed and motion coordinates. The effect is rather 
unnerving.

Only a few NPC sprites have walking animations, and those that do, do not get 
the animation invoked when moving the NPC, due to the problem in the NPC walking 
code, which looks a bit silly. You might have better success by defining a job-
sprite based sprite id in 'db/mob_avail.txt' with this.

---------------------------------------

*movenpc "<NPC name>",<x>,<y>{,<dir>};

This command looks like the NPCWalkToxy function,but is a little different.

While NPCWalkToXY just makes the NPC 'walk' to the coordinates given (which 
sometimes gives problems if the path isn't a straight line without objects), 
this command just moves the NPC. It basically warps out and in on the current 
and given spot. Direction can be used to change the NPC's facing direction.

Example:

// This will move Bugga from to the coordinates 100,20 (if those coordinates are legit).
	moveNPC "Bugga",100,20;

---------------------------------------

=====================
|6.- Other commands.|
=====================
---------------------------------------

*debugmes "<message>";

This command will send the message to the server console (map-server window). It 
will not be displayed anywhere else.

    // Displays "NAME has clicked me!" in the map-server window.
    debugmes strcharinfo(0)+" has clicked me!";

---------------------------------------

*logmes "<message>";

This command will write the message given to the map server NPC log file, as 
specified in 'conf/log_athena.conf'. In the TXT version of the server, the log 
file is 'log/npclog.log' by default. In the SQL version, if SQL logging is 
enabled, the message will go to the 'npclog' table, otherwise, it will go to the 
same log file.

If logs are not enabled, nothing will happen.

---------------------------------------

*globalmes "<message>"{,"<NPC name>"};

This command will send a message to the chat window of all currently connected 
characters.

If NPC name is specified, the message will be sent as if the sender would be
the NPC with the said name.

---------------------------------------

*rand(<number>{,<number>});

This function returns a number ...
(if you specify one) ... randomly positioned between 0 and the number you specify -1.
(if you specify two) ... randomly positioned between the two numbers you specify.

rand(10)  would result in 0,1,2,3,4,5,6,7,8 or 9
rand(0,9) would result in 0,1,2,3,4,5,6,7,8 or 9
rand(2,5) would result in 2,3,4 or 5

---------------------------------------

*viewpoint <action>,<x>,<y>,<point number>,<color>;

This command will mark places on the mini map in the client connected to the 
invoking character. It uses the normal X and Y coordinates from the main map. 
The colors of the marks are defined using a hexadecimal number, same as the ones 
used to color text in 'mes' output, but are written as hexadecimal numbers in C. 
(They look like 0x<six numbers>.)

Action is what you want to do with a point, 1 will set it, while 2 will clear 
it. 0 will also set it, but automatically removes the point after 15 seconds.
Point number is the number of the point - you can have several. If more than 
one point is drawn at the same coordinates, they will cycle, which can be used 
to create flashing marks.

    // This command will show a mark at coordinates X 30 Y 40, is mark number 1, 
    // and will be red.

    viewpoint 1,30,40,1,0xFF0000;

This will create three points:

    viewpoint 1,30,40,1,0xFF0000;
    viewpoint 1,35,45,2,0xFF0000;
    viewpoint 1,40,50,3,0xFF0000;

And this is how you remove them:

    viewpoint 2,30,40,1,0xFF0000;
    viewpoint 2,35,45,2,0xFF0000;
    viewpoint 2,40,50,3,0xFF0000;

The client determines what it does with the points entirely, the server keeps no 
memory of where the points are set whatsoever.

---------------------------------------

*cutin "<filename>",<position>;

This command will display a picture, usually an NPC illustration, also called
cutin, for the currently attached client. The position parameter determines the
placement of the illustration and takes following values:

    0 - bottom left corner 
    1 - bottom middle 
    2 - bottom right corner 
    3 - middle of screen in a movable window with an empty title bar 
    4 - middle of screen without the window header, but still movable 

The picture is read from data\texture\유저인터페이스\illust, from both the GRF archive
and data folder, and is required to be a bitmap. The file extension .bmp can be
omitted. Magenta color (#ff00ff) is considered transparent. There is no limit
placed on the size of the illustrations by the client, although loading of large
pictures (about 700x700 and larger) causes the client to freeze shortly (lag).
Typically the size is about 320x480. New illustrations can be added by just
putting the new file into the location above.

The client is able to display only one cutin at the same time and each new one
will cause the old one to disappear. To delete the currently displayed
illustration without displaying a new one, an empty file name and position 255
must be used.

    // Displays the Comodo Kafra illustration in lower right corner.
    cutin "kafra_07",2;

    // Typical way to end a script, which displayed an illustration during a
    // dialog with a player.
    mes "See you.";
    close2;
    cutin "",255;
    end;

---------------------------------------

*emotion <emotion number>{,<target>{,"<target name>"}};

This command makes an object display an emotion sprite above their own as 
if they were doing that emotion. For a full list of emotion numbers, 
see 'db/const.txt' under 'e_'. The not so obvious ones are 'e_what' (a question mark) 
and 'e_gasp' (the exclamation mark).

The optional target parameter specifies who will get the emotion on top of
their head. If 0 (the default if omitted), the NPC in current use will show
the emotion, if 1, the player that is running the script will display it.

Target name parameter allows to display emotion on top of other NPC/PC without
event labels. If specified name is not found, command does nothing.

---------------------------------------

*misceffect <effect number>;

This command, if run from an NPC object that has a sprite, will call up a 
specified effect number, centered on the NPC sprite. If the running code does 
not have an object ID (a 'floating' NPC) or is not running from an NPC object at 
all (an item script) the effect will be centered on the character who's RID got 
attached to the script, if any. For usable item scripts, this command will 
create an effect centered on the player using the item.

A full list of known effects is found in 'doc/effect_list.txt'. The list of 
those that actually work may differ greatly between client versions.

---------------------------------------

*soundeffect "<effect filename>",<type>;
*soundeffectall "<effect filename>",<type>{,"<map name>"}{,<x0>,<y0>,<x1>,<y1>};

These two commands will play a sound effect to either the invoking character 
only ('soundeffect') or multiple characters ('soundeffectall'). If the running 
code does not have an object ID (a 'floating' NPC) or is not running from an NPC 
object at all (an item script) the sound will be centered on the character who's 
RID got attached to the script, if any. If it does, it will be centered on that 
object. (an NPC sprite)

Effect filename is the filename in a GRF. It must have the .wav extension.

It's not quite certain what the 'type' actually does, it is sent to the client 
directly. It probably determines which directory to play the effect from.
It's certain that giving 0 for the number will play sound files from '\data\wav\',
but where the other numbers will read from is unclear.

The sound files themselves must be in the PCM format, and file names should also
have a maximum length of 23 characters including the .wav extension:

soundeffect "1234567890123456789.wav", 0; // this will play the soundeffect
soundeffect "12345678901234567890.wav", 0; // throw gravity error 

You can add your own effects this way, naturally.

---------------------------------------

*playBGM "<BGM filename>";
*playBGMall "<BGM filename>"{,"<map name>"{,<x0>,<y0>,<x1>,<y1>}};

These two commands will play a Background Music to either the invoking character 
only ('playBGM') or multiple characters ('playBGMall').

BGM filename is the filename in /BGM/ folder. It has to be in .mp3 extension.

It's not required to specify the extension inside the script.
If coordinates are omitted, BGM will be broadcasted on the entire map. If the map name
is omitted as well the BGM will be played for the entire server.

You can add your own BGMs this way, naturally.

---------------------------------------

*pvpon "<map name>";
*pvpoff "<map name>";

These commands will turn PVP mode for the specified maps on and off. Beside 
setting the flags referred to in 'setmapflag', 'pvpon' will also create a PVP 
timer and ranking as will @pvpon GM command do.

---------------------------------------

*atcommand "<command>";

This command will run the given command line exactly as if it was typed in from 
the keyboard by the player connected to the invoking character, and that 
character belonged to an account which had GM level 99.

    // This will ask the invoker for a character name and then use the '@nuke'
    // GM command on them, killing them mercilessly.
    input @player$;
    atcommand "@nuke "+@player$;

Note that for atcommands bound using 'bindatcmd', this command will execute the
original atcommand, not the script-bound atcommand.

---------------------------------------

*charcommand "<command>";

This command will run the given command line exactly as if it was typed in from 
the keyboard from a character that belonged to an account which had GM level 99.

The commands can also run without an attached rid.

    // This would do the same as above, but now
    // it doesn't need a player attached by default.
    charcommand "#option 0 0 0 Roy";

---------------------------------------

*bindatcmd "<command>","<NPC object name>::<event label>"{,<atcommand level>,<charcommand level>};

This command will bind a NPC event label to an atcommand. Upon execution of the
atcommand, the user will invoke the NPC event label. Each atcommand is only allowed
one binding. If you rebind, it will override the original binding.

The following variables are set upon execution:
	.@atcmd_command$       =  The name of the @command used.
	.@atcmd_parameters$[]  =  Array containing the given parameters, starting from an index of 0.
	.@atcmd_numparameters  =  The number of parameters defined.

Example:

When a user types the command "@test", an angel effect will be shown.

-	script	atcmd_example	-1,{
OnInit:
	bindatcmd "test",strnpcinfo(3)+"::OnAtcommand";
	end;
OnAtcommand:
	specialeffect2 338;
	end;
}

---------------------------------------

*unbindatcmd "<command>";

This command will unbind a NPC event label from an atcommand.

---------------------------------------

*useatcmd "<command>";

This command will execute a script-bound atcommand for the attached RID. If the
supplied command is not bound to any script, this command will act like 'atcommand'
and attempt to execute a source-defined command.

The three .@atcmd_***** variables will NOT be set when invoking script-bound atcommands
in this way.

---------------------------------------
\\
6,1.- Unit-related commands
\\
---------------------------------------

*unitwalk <GID>,<x>,<y>;
*unitwalk <GID>,<Target ID>;

This command will tell a <GID> to walk to a position, defined either as a set of
coordinates or another object. The command returns a 1 for success and 0 upon failure.

If coordinates are passed, the <GID> will walk to the given x,y coordinates on the
unit's current map. While there is no way to move across an entire map with 1 command
use, this could be used in a loop to move long distances.

If an object ID is passed, the initial <GID> will walk to the <Target ID> (similar to
walking to attack). This is based on the distance from <GID> to <Target ID>. This command
uses a hard walk check, so it will calculate a walk path with obstacles. Sending a bad
target ID will result in an error.

Examples:

// Makes player walk to the coordinates (150,150).
	unitwalk getcharid(3),150,150;

// Performs a conditional check with the command and reports success or failure to the player.
	if(unitwalk(getcharid(3),150,150))
		dispbottom "Walking you there...";
	else
		dispbottom "That's too far away, man.";

// Makes player walk to another character named "WalkToMe".
	unitwalk getcharid(3),getcharid(3,"WalkToMe");

---------------------------------------

*unitattack <GID>,<Target ID>{,<action type>};
*unitattack <GID>,"<Target Name>"{,<action type>};

This command will make a <GID> attack the specified target. It returns 1 upon
success and 0 for all failures.

If <GID> is a player and a non-zero <action type> is given, the unit will perform a
continuous attack instead of a single attack.

---------------------------------------

*unitkill <GID>;

This command will kill a <GID>.

---------------------------------------

*unitwarp <GID>,"<map name>",<x>,<y>;

This command will warp a <GID> to the specified map and coordinates.

If <GID> is zero, the command runs for the unit that invoked the script. This can be
used with "OnTouch" to warp monsters:

OnTouch:
	unitwarp 0,"this",-1,-1;

---------------------------------------

*unitstop <GID>;

This command will make a <GID> stop attacking and moving.

---------------------------------------

*unittalk <GID>,"<text>";

This command will make a <GID> say a message.

---------------------------------------

*unitemote <GID>,<emotion number>;

This command will make a <GID> display an emotion sprite.
For a full list of emotion numbers, see 'db/const.txt' under 'e_'.

---------------------------------------

*unitskilluseid <GID>,<skill id>,<skill lvl>{,<target id>};
*unitskilluseid <GID>,"<skill name>",<skill lvl>{,<target id>};
*unitskillusepos <GID>,<skill id>,<skill lvl>,<x>,<y>;
*unitskillusepos <GID>,"<skill name>",<skill lvl>,<x>,<y>;

This is the replacement of the older commands, these use the same values for
GID as the other unit* commands (See 'GID').

Skill ID is the ID of the skill, skill level is the level of the skill.
For the position, the x and y are given in the unitSkillUsePos.

---------------------------------------
\\
6,1.- End of unit-related commands
\\
---------------------------------------

*npcskill <skill id>,<skill lvl>,<stat point>,<NPC level>;
*npcskill "<skill name>",<skill lvl>,<stat point>,<NPC level>;

This command causes the attached NPC object to cast a skill on the attached
player. The skill will have no cast time or cooldown. The player must be
within the default skill range or the command will fail silently.

The "stat point" parameter temporarily sets all NPC stats to the given value,
and "NPC level" is the temporary level of the NPC (used in some skills).
Neither value can be greater than the max level defined in config, and will
not work properly if the NPC has a mob sprite.

    // Casts Level 10 Heal on the attached player, calculated with
    // all stats 99 and base level 60.
    npcskill "AL_HEAL",10,99,60;

---------------------------------------

*day;
*night;

These two commands will switch the entire server between day and night mode
respectively. If your server is set to cycle between day and night by
configuration, it will eventually return to that cycle.

Example:

-	script	DayNight	-1,{
OnClock0600:
	day;
	end;
OnInit:
	// setting correct mode upon server start-up
	if(gettime(3)>=6 && gettime(3)<18) end;
OnClock1800:
	night;
	end;
}

This script allows to emulate the day/night cycle as the server does, but also
allows triggering additional effects upon change, like announces, gifts, etc.
The day/night cycle set by configuration should be disabled when this script is used.

---------------------------------------

*defpattern <set number>,"<regular expression pattern>","<event label>";
*activatepset <set number>;
*deactivatepset <set number>;
*deletepset <set number>;

This set of commands is only available if the server is compiled with regular 
expressions library enabled. Default compilation and most binary distributions 
aren't, which is probably bad, since these, while complex to use, are quite 
fascinating.

They will make the NPC object listen for text spoken publicly by players and 
match it against regular expression patterns, then trigger labels associated 
with these regular expression patterns.

Patterns are organized into sets, which are referred to by a set number. You can 
have multiple sets patterns, and multiple patterns may be active at once. 
Numbers for pattern sets start at 1.

'defpattern' will associate a given regular expression pattern with an event 
label. This event will be triggered whenever something a player says is matched 
by this regular expression pattern, if the pattern is currently active.

'activatepset' will make the pattern set specified active. An active pattern 
will enable triggering labels defined with 'defpattern', which will not happen 
by default.
'deactivatepset' will deactivate a specified pattern set. Giving -1 as a pattern 
set number in this case will deactivate all pattern sets defined.

'deletepset' will delete a pattern set from memory, so you can create a new 
pattern set in its place.

Using regular expressions is high wizardry. But with this high wizardry comes 
unparalleled power of text manipulation. For an explanation of what a regular 
expression pattern is, see a few web pages:

http://www.regular-expressions.info/
http://www.weitz.de/regex-coach/

For an example of this in use, see doc/sample/npc_test_pcre.txt

With this you could, for example, automatically punish players for asking for 
Zeny in public places, or alternatively, automatically give them Zeny instead if 
they want it so much.

---------------------------------------

*pow(<number>,<power>)

Returns the result of the calculation.

Example:
	.@i = pow(2,3); // .@i will be 8

---------------------------------------

*sqrt(<number>)

Returns the square-root of a number.

Example:
	.@i = sqrt(25); // .@i will be 5

---------------------------------------

*distance(<x0>,<y0>,<x1>,<y1>)

Returns distance between 2 points.

Example:
	.@i = distance(100,200,101,202);

---------------------------------------

*md5("<string>")

Returns the md5 checksum of a number or string.

Example:
	mes md5(12345);
	mes md5("12345"); 	// Will both display 827ccb0eea8a706c4c34a16891f84e7b
	mes md5("qwerty"); 	// Will display d8578edf8458ce06fbc5bb76a58c5ca4

---------------------------------------

*query_sql("your MySQL query"{, <array variable>{, <array variable>{, ...}}});
*query_logsql("your MySQL query"{, <array variable>{, <array variable>{, ...}}});

Executes an SQL query. A 'select' query can fill array variables with up to 128 rows of values,
and will return the number of rows (i.e. array size) or -1 on failure/empty array.

Note that 'query_sql' runs on the main database while 'query_logsql' runs on the log database.

Example:
	.@nb = query_sql("select name,fame from `char` ORDER BY fame DESC LIMIT 5", .@name$, .@fame);
	mes "Hall Of Fame: TOP5";
	mes "1."+.@name$[0]+"("+.@fame[0]+")"; // largest fame value.
	mes "2."+.@name$[1]+"("+.@fame[1]+")";
	mes "3."+.@name$[2]+"("+.@fame[2]+")";
	mes "4."+.@name$[3]+"("+.@fame[3]+")";
	mes "5."+.@name$[4]+"("+.@fame[4]+")";

---------------------------------------

*escape_sql(<value>)

Converts the value to a string and escapes special characters so that it is safe to
use in query_sql(). Returns the escaped form of the given value.

Example:
	.@name$ = "John's Laptop";
	.@esc_str$ = escape_sql(.@name$); // Escaped string: John\'s Laptop

---------------------------------------

*setiteminfo(<item id>,<type>,<value>)

This function will set some value of an item.
Returns the new value on success, or -1 on fail (item_id not found or invalid type).

Valid types are:
	0 - Buy Price; 1 - Sell Price; 2 - Item Type;
	3 - maxchance (Max drop chance of this item e.g. 1 = 0.01% , etc..
		if = 0, then monsters don't drop it at all (rare or a quest item)
		if = 10000, then this item is sold in NPC shops only
	4 - sex; 5 - equip; 6 - weight; 7 - atk; 8 - def; 9 - range;
	10 - slot; 11 - look; 12 - elv; 13 - wlv; 14 - view id

Example:
	setiteminfo 7049,6,9990; // Stone now weighs 999.0

---------------------------------------

*setitemscript(<item id>,<"{ new item script }">{,<type>});

Set a new script bonus to the Item. Very useful for game events.
You can remove an item's itemscript by leaving the itemscript argument empty.
Returns 1 on success, or 0 on fail (item_id not found or new item script is invalid).
Type can optionally be used indicates which script to set (default is 0):
 0 - Script
 1 - OnEquip_Script
 2 - OnUnequip_Script

Example:
	setitemscript 2637,"{ if(isequipped(2236)==0)end; if(getskilllv(26)){skill 40,1;}else{skill 26,1+isequipped(2636);} }";
	setitemscript 2637,"";

---------------------------------------

*atoi("<string>")
*axtoi("<string>")
*strtol("<string>", base)

These commands are used to convert strings to numbers. 'atoi' will interpret
given string as a decimal number (base 10), while 'axtoi' interprets strings as
hexadecimal numbers (base 16). 'strtol' lets the user specify a base (valid range
is between 2 and 36 inclusive, or the special value0, which means auto-detection).

The 'atoi' and 'strtol' functions conform to the C functions with the same names,
and 'axtoi' is the same as strtol, with a base of 16. Results are clamped to signed
32 bit int range (INT_MIN ~ INT_MAX).

Examples:

	.@var = atoi("11");        // Sets .@var to 11
	.@var = axtoi("FF");       // Sets .@var to 255
	mes axtoi("11");           // Displays 17 (1 = 1, 10 = 16)
	.@var = strtol("11", 10);  // Sets .@var to 11 (11 base 10)
	.@var = strtol("11", 16);  // Sets .@var to 17 (11 base 16)
	.@var = strtol("11", 0);   // Sets .@var to 11 (11 base 10, auto-detected)
	.@var = strtol("0x11", 0); // Sets .@var to 17 (11 base 16, auto-detected because of the "0x" prefix)
	.@var = strtol("011", 0);  // Sets .@var to 9 (11 base 8, auto-detected because of the "0" prefix)
	.@var = strtol("11", 2);   // Sets .@var to 3 (binary 11)

---------------------------------------

*compare("<string>","<substring>")

This command returns 1 or 0 when the substring is in the main string (1) or not (0).
This command is not case sensitive.

Examples:
	//dothis; will be executed ('Bloody Murderer' contains 'Blood').
	if (compare("Bloody Murderer","Blood"))
		dothis;

	//dothat; will not be executed ('Blood butterfly' does not contain 'Bloody').
	if (compare("Blood Butterfly","Bloody"))
		dothat;

---------------------------------------

*strcmp("<string>","<string>")

This command compares two strings are returns a value:
   1: string 1 > string 2
   0: strings are equal
  -1: string 1 < string 2

---------------------------------------

*getstrlen("<string>")

This function will return the length of the string given as an argument. It is 
useful to check if anything input by the player exceeds name length limits and 
other length limits and asking them to try to input something else.

---------------------------------------

*charisalpha("<string>",<position>)

This function will return 1 if the character number Position in the given string 
is a letter, 0 if it isn't a letter but a digit or a space.
The first letter is position 0.

---------------------------------------

*charat(<string>,<index>)

Returns char at specified index. If index is out of range, returns empty string.
The first letter of a string is index 0.

Example:
	charat("This is a string", 10); //returns "s"

---------------------------------------

*setchar(<string>,<char>,<index>)

Returns the original string with the char at the specified index set to the
specified char. If index out of range, the original string will be returned.
Only the 1st char in the <char> parameter will be used.

Example:
	setchar("Cat", "B", 0); //returns "Bat"

---------------------------------------

*insertchar(<string>,<char>,<index>)

Returns the original string with the specified char inserted at the specified
index. If index is out of range, the char will be inserted on the end of the
string that it is closest. Only the 1st char in the <char> parameter will be used.

Example:
	insertchar("laughter", "s", 0); //returns "slaughter"

---------------------------------------

*delchar(<string>,<index>)

Returns the original string with the char at the specified index removed.
If index is out of range, original string will be returned.

Example:
	delchar("Diet", 3); //returns "Die"

---------------------------------------

*strtoupper(<string>)
*strtolower(<string>)

Returns the specified string in its uppercase/lowercase form.
All non-alpha characters will be preserved.

Example:
	strtoupper("The duck is blue!!"); //returns "THE DUCK IS BLUE!!"

---------------------------------------

*charisupper(<string>,<index>)
*charislower(<string>,<index>)

Returns 1 if character at specified index of specified string is
uppercase/lowercase. Otherwise, 0. Characters not of the alphabet will return 0.

Example:
	charisupper("rAthena", 1); //returns 1

---------------------------------------

*substr(<string>,<start_index>,<end_index>)

Returns the sub-string of the specified string inclusively between the set
indexes. If indexes are out of range, or the start index is after the end
index, an empty string will be returned.

Example:
	substr("foobar", 3, 5); //returns "bar"

---------------------------------------

*explode(<dest_array>,<string>,<delimiter>)

Breaks a string up into substrings based on the specified delimiter. Substrings
will be stored within the specified string array. Only the 1st char of the
delimiter parameter will be used. If an empty string is passed as a delimiter,
the string will be placed in the array in its original form.

Example:
	explode(.@my_array$, "Explode:Test:1965:red:PIE", ":");
	//.@my_array$ contents will be...
	//.@my_array$[0]: "Explode"
	//.@my_array$[1]: "Test"
	//.@my_array$[2]: "1965"
	//.@my_array$[3]: "red"
	//.@my_array$[4]: "PIE"

---------------------------------------

*implode(<string_array>{,<glue>})

Combines all substrings within the specified string array into a single string.
If the glue parameter is specified, it will be inserted inbetween each substring.

Example:
	setarray .@my_array$[0], "This", "is", "a", "test";
	implode(.@my_array$, " "); //returns "This is a test"

---------------------------------------

*sprintf(<format>[,param[,param[,...]]])

C style sprintf. The resulting string is returned same as in PHP. All C format 
specifiers are supported except %n. More info: sprintf @ www.cplusplus.com. 
The number of params is only limited by rA's script engine.

Example:
	.@format$ = "The %s contains %d monkeys";
	dispbottom(sprintf(.@format$, "zoo", 5));        //prints "The zoo contains 5 monkeys"
	dispbottom(sprintf(.@format$, "barrel", 82));    //prints "The barrel contains 82 monkeys"

---------------------------------------

*sscanf(<string>,<format>[,param[,param[,...]]])

C style sscanf. All C format specifiers are supported. 
More info: sscanf @ www.cplusplus.com. The number of params is only limited 
by rA's script engine.

Example:
	sscanf("This is a test: 42 foobar", "This is a test: %d %s", .@num, .@str$);
	dispbottom(.@num + " " + .@str$); //prints "42 foobar"

---------------------------------------

*strpos(<haystack>,<needle>{,<offset>})

PHP style strpos. Finds a substring (needle) within a string (haystack).
The offset parameter indicates the index of the string to start searching.
Returns index of substring on successful search, else -1.
Comparison is case sensitive.

Example:
	strpos("foobar", "bar", 0); //returns 3
	strpos("foobarfoo", "foo", 0); //returns 0
	strpos("foobarfoo", "foo", 1); //returns 6

---------------------------------------

*replacestr(<input>, <search>, <replace>{, <usecase>{, <count>}})

Replaces all instances of a search string in the input with the specified
replacement string. By default is case sensitive unless <usecase> is set
to 0. If specified it will only replace as many instances as specified
in the count parameter.

Example:
	replacestr("testing tester", "test", "dash"); //returns "dashing dasher"
	replacestr("Donkey", "don", "mon", 0); //returns "monkey"
	replacestr("test test test test test", "test", "yay", 0, 3); //returns "yay yay yay test test"

---------------------------------------

*countstr(<input>, <search>{, <usecase>})

Counts all instances of a search string in the input. By default is case
sensitive unless <usecase> is set to 0.

Example:
	countstr("test test test Test", "test"); //returns 3
	countstr("cake Cake", "Cake", 0); //returns 2

---------------------------------------

*preg_match(<regular expression pattern>,<string>{,<offset>})

Searches a string for a match to the regular expression provided. The
offset parameter indicates the index of the string to start searching.
Returns offsets to captured substrings, or 0 if no match is found.

This command is only available if the server is compiled with the regular 
expressions library enabled.

---------------------------------------

*setfont <font>;

This command sets the current RO client interface font to one of the
fonts stored in data\*.eot by using an ID of the font. When the ID
of the currently used font is used, default interface font is used
again.

    0 - Default
    1 - RixLoveangel
    2 - RixSquirrel
    3 - NHCgogo
    4 - RixDiary
    5 - RixMiniHeart
    6 - RixFreshman
    7 - RixKid
    8 - RixMagic
    9 - RixJJangu

---------------------------------------

*showdigit <value>{,<type>};

Displays given numeric 'value' in large digital clock font on top of
the screen. The optional parameter 'type' specifies visual aspects
of the "clock" and can be one of the following values:

    0 - Displays the value for 5 seconds (default).
    1 - Incremental counter (1 tick/second).
    2 - Decremental counter (1 tick/second). Does not stop at zero,
        but overflows.
    3 - Decremental counter (1 tick/second). Two digits only, stops
        at zero.

For type 1 and 2 the start value is set by using negative number of
the one intended to set (ex. -10 starts the counter at 10 seconds).
Except for type 3 the value is interpreted as seconds and formatted
as time in days, hours, minutes and seconds. Note, that the official
script command does not have the optional parameter.

    // displays 23:59:59 for 5 seconds
    showdigit 86399;

    // counter that starts at 60 and runs for 60 seconds
    showdigit 60,3;

---------------------------------------

*setcell "<map name>",<x1>,<y1>,<x2>,<y2>,<type>,<flag>;

Each map cell has several 'flags' that specify the properties of that cell.
These include terrain properties (walkability, shootability, presence of water),
skills (basilica, land protector, ...) and other (NPC nearby, no vending, ...).
Each of these can be 'on' or 'off'. Together they define a cell's behavior.

This command lets you alter these flags for all map cells in the specified
(x1,y1)-(x2,y2) rectangle. The 'flag' can be 0 or 1 (0:clear flag, 1:set flag).
The 'type' defines which flag to modify. Possible options see 'db/const.txt'.

Example:

	setcell "arena",0,0,300,300,cell_basilica,1;
	setcell "arena",140,140,160,160,cell_basilica,0;
	setcell "arena",135,135,165,165,cell_walkable,0;
	setcell "arena",140,140,160,160,cell_walkable,1;

This will add a makeshift ring into the center of the map. The ring will be
surrounded by a 5-cell wide 'gap' to prevent interference from outside, and
the rest of the map will be marked as 'basilica', preventing observers from
casting any offensive skills or fighting among themselves. Note that the wall
will not be shown nor known client-side, which may cause movement problems.

Another example:

OnBarricadeDeploy:
	setcell "schg_cas05",114,51,125,51,cell_walkable,0;
	end;
OnBarricadeBreak:
	setcell "schg_cas05",114,51,125,51,cell_walkable,1;
	end;

This could be a part of the WoE:SE script, where attackers are not allowed
to proceed until all barricades are destroyed. This script would place and
remove a nonwalkable row of cells after the barricade mobs.
	
---------------------------------------

*checkcell ("<map name>",<x>,<y>,<type>);

This command will return 1 or 0, depending on whether the specified cell has
the 'type' flag set or not. There are various types to check, all mimicking
the server's cell_chk enumeration. The types can be found in 'db/const.txt'.

The meaning of the individual types can be confusing, so here's an overview:
  - cell_chkwall/water/cliff
    these check directly for the 'terrain component' of the specified cell
  - cell_chkpass/reach/nopass/noreach
    passable = not wall & not cliff, reachable = passable wrt. no-stacking mod
  - cell_chknpc/basilica/landprotector/novending/nochat
    these check for specific dynamic flags (their name indicates what they do)

Example:
	mes "Pick a destination map.";
	input .@map$;
	mes "Alright, now give me the coordinates.";
	input .@x;
	input .@y;
	if( !checkcell(.@map$,.@x,.@y,cell_chkpass) ) {
		mes "Can't warp you there, sorry!";
		close;
	} else {
		mes "Ok, get ready...";
		close2;
		warp .@map$, .@x, .@y;
		end;
	}

---------------------------------------

*setwall "<map name>",<x>,<y>,<size>,<dir>,<shootable>,"<name>";
*delwall "<name>";

Creates an invisible wall, an array of "setcell" starting from x,y and doing a
line of the given size in the given direction. The difference with setcell is
this one update client part too to avoid the glitch problem. Directions are the 
same as NPC sprite facing directions: 0=north, 1=northwest, 2=west, etc.

---------------------------------------

*readbook <book id>,<page>;

This command will open a book item at the specified page.

---------------------------------------

========================
|7.- Instance commands.|
========================
---------------------------------------

*instance_create("<instance name>");

Creates an instance for the party of the attached player. The instance name,
along with all other instance data, is read from 'db/(pre-)re/instance_db.txt'.
Upon success, the command generates a unique instance ID, duplicates all listed
maps and NPCs, sets the alive time, and triggers the "OnInstanceInit" label in
all NPCs inside the instance.

The command returns the instance ID upon success, and these values upon failure:
 -1: Invalid type.
 -2: Party not found.
 -3: Instance already exists.
 -4: No free instances (MAX_INSTANCE exceeded).

---------------------------------------

*instance_destroy {<instance id>};

Destroys instance with the ID <instance id>. If no ID is specified, the instance
the script is attached to is used. If the script is not attached to an instance,
the instance of the currently attached player's party is used. If that fails,
the script will come to a halt.

---------------------------------------

*instance_enter("<instance name>"{,<x>,<y>});

Warps player to the specified instance after the script terminates. The map and
coordinates are located in 'db/(pre-)re/instance_db.txt'.

The command returns 0 upon success, and these values upon failure:
 1: Party not found.
 2: Party does not have an instance.
 3: Other errors (invalid instance name, instance doesn't match with party).

---------------------------------------

*instance_npcname("<npc name>"{,<instance id>})

Returns the unique name of the instanced script. If no ID is specified,
the instance the script is attached to is used. If the script is not attached to
an instance, the instance of the currently attached player's party is used. If
that fails, the script will come to a halt.

---------------------------------------

*instance_mapname("<map name>"{,<instance id>})

Returns the unique name of the instanced map. If no instance ID is specified,
the instance the script is attached to is used. If the script is not attached to
an instance, the instance of the currently attached player's party is used. If
that fails, the command returns an empty string instead.

---------------------------------------

*instance_id()

Returns the unique instance id of the attached script. If the script is not
attached to an instance, the instance of the currently attached player's party is
used. If that fails, the function will return 0.

---------------------------------------

*instance_warpall "<map name>",<x>,<y>{,<instance id>};

Warps all players in the instance <instance id> to <map name> at given
coordinates. If no ID is specified, the instance the script is attached to
is used. If the script is not attached to an instance, the instance of the
currently attached player's party is used. If that fails, the script will
come to a halt.

---------------------------------------

*instance_announce <instance id>,"<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}};

Broadcasts a message to all players in the instance <instance id> currently
residing on an instance map. If -1 is specified for <instance id>, the instance
the script is attached to is used. If the script is not attached to an instance,
the instance of the currently attached player's party is used.

For details on the other parameters, see 'announce'.

---------------------------------------

*instance_check_party(<party id>{,<amount>{,<min>{,<max>}}})

This function checks if a party meets certain requirements, returning 1 if all
conditions are met and 0 otherwise. It will only check online characters.

amount - number of online party members (default is 1).
min    - minimum level of all characters in the party (default is 1).
max    - maximum level of all characters in the party (default is max level in conf).

Example:

if (instance_check_party(getcharid(1),2,2,149)) {
	mes "Your party meets the Memorial Dungeon requirements.",
	mes "All online members are between levels 1-150 and at least two are online.";
	close;
} else {
	mes "Sorry, your party does not meet requirements.";
	close;
}

---------------------------------------

=========================
|8.- Quest Log commands.|
=========================
---------------------------------------

*questinfo <Quest ID>, <Icon> {, <Map Mark Color>{, <Job Class>}};

This is esentially a combination of checkquest and showevent. Use this only
in an OnInit label. For the Quest ID, specify the quest ID that you want
checked if it has been started yet.

For Icon, use one of the following:

No Icon			: QTYPE_NONE
! Quest Icon	: QTYPE_QUEST
? Quest Icon	: QTYPE_QUEST2
! Job Icon		: QTYPE_JOB
? Job Icon		: QTYPE_JOB2
! Event Icon	: QTYPE_EVENT
? Event Icon	: QTYPE_EVENT2
Warg			: QTYPE_WARG
Warg Face		: QTYPE_WARG2 (Only for packetver >= 20120410)

Map Mark Color, when used, creates a mark in the user's mini map on the position of the NPC,
the available color values are:

0 - No Marker
1 - Yellow Marker
2 - Green Marker
3 - Purple Marker

When a user shows up on a map, each NPC is checked for questinfo that has been set.
If questinfo is present, it will check if the quest has been started, if it has not, the bubble will appear.

Optionally, you can also specify a Job Class if the quest bubble should only appear for a certain class.

Example
izlude,100,100,4	script	Test	844,{
	mes "[Test]";
	mes "Hello World.";
	close;

	OnInit:
		questinfo 1001, QTYPE_QUEST, 0, Job_Novice;
		end;
}

---------------------------------------

*setquest <ID>;

Place quest of <ID> in the users quest log, the state of which is "active".

If *questinfo is set, and the same ID is specified here, the icon will be cleared when the quest is set.

---------------------------------------

*completequest <ID>;

Change the state for the given quest <ID> to "complete" and remove from the users quest log.

---------------------------------------

*erasequest <ID>;

Remove the quest of the given <ID> from the user's quest log.

---------------------------------------

*changequest <ID>,<ID2>;

Remove quest of the given <ID> from the user's quest log.
Add quest of the <ID2> to the the quest log, and the state is "active".

---------------------------------------

*checkquest(<ID>{,PLAYTIME|HUNTING})

If no additional argument supplied, return the state of the quest: 
	-1 = Quest not started (not in quest log)
	0  = Quest has been given, but the state is "inactive"
	1  = Quest has been given, and the state is "active"
	2  = Quest completed

If parameter "PLAYTIME" is supplied:
	-1 = Quest not started (not in quest log)
	0  = the time limit has not yet been reached
	1  = the time limit has not been reached but the quest is marked as complete
	2  = the time limit has been reached

If parameter "HUNTING" is supplied:
	-1 = Quest not started (not in quest log)
	0  = you haven't killed all of the target monsters and the time limit has not been reached.
	1  = you haven't killed all of the target monsters but the time limit has been reached.
	2  = you've killed all of the target monsters

---------------------------------------

*isbegin_quest(<ID>)

Return the state of the quest: 
	0  = Quest not started (not in quest log)
	1  = Quest has been given (state is either "inactive" or "active")
	2  = Quest completed

---------------------------------------

*showevent <icon>{,<mark color>}

Show an emotion on top of a NPC, and optionally,
a colored mark in the mini-map like "viewpoint".
This is used to indicate that a NPC has a quest or an event to 
a certain player. 

Available Icons:

Remove Icon		: QTYPE_NONE
! Quest Icon	: QTYPE_QUEST
? Quest Icon	: QTYPE_QUEST2
! Job Icon		: QTYPE_JOB
? Job Icon		: QTYPE_JOB2
! Event Icon	: QTYPE_EVENT
? Event Icon	: QTYPE_EVENT2
Warg			: QTYPE_WARG
Warg Face		: QTYPE_WARG2 (Only for packetver >= 20120410)

Mark Color:
0 - No Mark
1 - Yellow Mark
2 - Green Mark
3 - Purple Mark

---------------------------------------

============================
|9.- Battleground commands.|
============================
---------------------------------------

*waitingroom2bg_single(<battle group>,"<map name>",<x>,<y>,"<npc name>");

Adds the first waiting player from the chat room of the given NPC to an
existing battleground group and warps it to the specified coordinates on
the given map.

---------------------------------------

*waitingroom2bg("<map name>",<x>,<y>,"<On Quit Event>","<On Death Event>"{,"<NPC Name>"});

<map name>,<x>,<y> refer to where the "respawn" base is, where the player group will respawn when they die.
<On Quit Event> refers to an NPC label that attaches to the character and is run when they relog.
<On Death Event> refers to an NPC label that attaches to the character and is run when they die. Can be "" for empty.

Unlike the prior command, the latter will attach a GROUP in a waiting room to the battleground, and 
sets the array $@arenamembers[0] where 0 holds the IDs of the first group, and 1 holds the IDs of the second.

If the optional NPC Name parameter is left out, the waiting room of the current NPC is used.

Example:
	// Battle Group will be referred to as $@KvM01BG_id1, and when they die, respawn at bat_c01,52,129.
	set $@KvM01BG_id1, waitingroom2bg("bat_c01",52,129,"KvM01_BG::OnGuillaumeQuit","KvM01_BG::OnGuillaumeDie");
	end;

---------------------------------------

*bg_team_setxy <Battle Group ID>,<x>,<y>;

Updates the respawn point of the given Battle Group to x,y on the same map. <Battle Group ID> can be retrieved using getcharid(4).

Example:
	bg_team_setxy getcharid(4),56,212;
	mapannounce "bat_a01", "Group [1] has taken the work shop, and will now respawn there.",bc_map,"0xFFCE00";
	end;

---------------------------------------

*bg_warp <Battle Group>,"<map name>",<x>,<y>;

Similar to the 'warp' command.
Places all members of <Battle Group> at the specified map and coordinates.

Example:
	//place the battle group one for Tierra Gorge at starting position.
	bg_warp $@TierraBG1_id1,"bat_a01",352,342;
	end;

---------------------------------------

*bg_monster <Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>";
*bg_monster(<Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>");

Similar to the 'monster' command.
Spawns a monster with allegiance to the given Battle Group.
Does not allow for the summoning of multiple monsters.
Monsters are similar to those in War of Emperium, in that the specified Battle Group is considered friendly.

Example:
	// It can be used in two different ways.
	bg_monster $@TierraBG1_id2,"bat_a01",167,50,"Food Depot",1910,"Feed Depot#1::OnMyMobDead";
	end;

	// Alternatively, you can set an ID for the monster using "set".
	// This becomes useful when used with the command below.
	set $@Guardian_3, bg_monster($@TierraBG1_id2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	end;

---------------------------------------

*bg_monster_set_team <GID>,<Battle Group>;

This command will change the allegiance if a monster in a battle ground.
GID can be set when spawning the monster via the 'bg_monster' command.

Example:

	end;

OnEnable:
	mapannounce "A guardian has been summoned for Battle Group 2!",bc_map,"0xFFCE00";
	set $@Guardian, bg_monster($@BG_2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	initnpctimer;
	end;

OnTimer1000:
	stopnpctimer;
	mapannounce "Erm, sorry about that! This monster was meant for Battle Group 1.",bc_map,"0xFFCE00";
	bg_monster_set_team $@Guardian, $@BG_1;
	end;

---------------------------------------

*bg_leave;

Removes attached player from their Battle Group.

---------------------------------------

*bg_destroy <Batte Group>;

Destroys the Battle Group created for that battle ground.

---------------------------------------

*areapercentheal "<map name>",<x1>,<y1>,<x2>,<y2>,<hp>,<sp>;

Restores a percentage of the maximum HP/SP of players within a defined area.
This is primarily used in battleground scripts, but is not limited to them.

Example:
	areapercentheal "bat_a01",52,208,61,217,100,100;
	end;

---------------------------------------

*bg_get_data(<Battle Group>,<type>);

Retrieves data related to given Battle Group. Type can be one of the following:

    0 - Amount of players currently belonging to the group.

---------------------------------------

*bg_getareausers(<Battle Group>,"<map name>",<x0>,<y0>,<x1>,<y1>);

Retrieves the amount of players belonging to the given Battle Group on the given
map within the specified rectangular area.

---------------------------------------

*bg_updatescore "<map name>",<Guillaume Score>,<Croix Score>;

This command will force the update of the displayed scoreboard.
It is only usable when the map is defined as a Type 2 Battleground:
mapflag	<map name>	battleground	2

---------------------------------------

====================
|10.- Pet commands.|
====================
---------------------------------------

*bpet;

This command opens up a pet hatching window on the client connected to the 
invoking character. It is used in item script for the pet incubators and will 
let the player hatch an owned egg. If the character has no eggs, it will just 
open up an empty incubator window.
This is still usable outside item scripts.

---------------------------------------

*pet <pet id>;

This command is used in all the item scripts for taming items. Running this 
command will make the pet catching cursor appear on the client connected to the 
invoking character, usable on the monsters with the specified pet ID number. It 
will still work outside an item script.

A full list of pet IDs can be found inside 'db/pet_db.txt'.

---------------------------------------

*makepet <pet id>;

This command will create a pet egg and put it in the invoking character's 
inventory. The kind of pet is specified by pet ID numbers listed in 
'db/pet_db.txt'. The egg is created exactly as if the character just successfully 
caught a pet in the normal way.

    // This will make you a poring:
    makepet 1002;

Notice that you absolutely have to create pet eggs with this command. If you try 
to give a pet egg with 'getitem', pet data will not be created by the char 
server and the egg will disappear when anyone tries to hatch it.

---------------------------------------

*getpetinfo(<type>)

This function will return pet information for the pet the invoking character 
currently has active. Valid types are:

 0 - Unique pet ID number as stored by the char server and distinguishing it 
     from all other pets the characters actually have. This value is currently 
     useless, at most you can use it to tell pets apart reliably.
 1 - Pet class number as per 'db/pet_db.txt' - will tell you what kind of a pet it 
     is.
 2 - Pet name. Will return "null" if there's no pet. 
 3 - Pet friendly level (intimacy score). 1000 is full loyalty.
 4 - Pet hungry level. 100 is completely full.
 5 - Pet rename flag. 0 means this pet has not been named yet.
 6 - Pet level


---------------------------------------

* The Pet AI commands
  -------------------

These commands will only work if the invoking character has a pet, and are meant 
to be executed from pet scripts. They will modify the pet AI decision-making for 
the current pet of the invoking character, and will NOT have any independent 
effect by themselves, which is why only one of them each may be in effect at any 
time for a specific pet. A pet may have 'petloot', 'petskillbonus', 
'petskillattack' OR 'petpetskillattack2' and 'petskillsupport' OR 'petheal' at 
the same time. 'petheal' is deprecated and is no longer used in the default pet 
scripts.

All commands with delays and durations will only make the behavior active for 
the specified duration of seconds, with a delay of the specified number of 
seconds between activations. Rates are a chance of the effect occurring and are 
given in percent. 'bonusrate' is added to the normal rate if the pet intimacy is 
at the maximum possible.

The behavior modified with the below mentioned commands will only be exhibited if 
the pet is loyal and appropriate configuration options are set in 
'battle_athena.conf'.

Pet scripts in the database normally run whenever a pet of that type hatches 
from the egg. Other commands usable in item scripts (see 'bonus') will also 
happily run from pet scripts. Apparently, the pet-specific commands will also 
work in NPC scripts and modify the behavior of the current pet up until the pet 
is hatched again. (Which will also occur when the character is logged in again 
with the pet still out of the egg.) It is not certain for how long the effect of 
such command running from an NPC script will eventually persist, but apparently, 
it is possible to usefully employ them in usable item scripts to create pet 
buffing items.

Nobody tried this before, so you're essentially on your own here.

---------------------------------------

*petskillbonus <bonus type>,<value>,<duration>,<delay>;

This command will make the pet give a bonus to the owner's stat (bonus type -
bInt,bVit,bDex,bAgi,bLuk,bStr,bSpeedRate - for a full list, see the values 
starting with 'b' in 'db/const.txt')

---------------------------------------

*petrecovery <status type>,<delay>;

This command will make the pet cure a specified status condition. The curing 
actions will occur once every Delay seconds. For a full list of status 
conditions that can be cured, see the list of 'SC_' status condition constants 
in 'db/const.txt'.

---------------------------------------

*petloot <max items>;

This command will turn on pet looting, with a maximum number of items to loot 
specified. Pet will store items and return them when the maximum is reached or 
when pet performance is activated.

---------------------------------------

*petskillsupport <skill id>,<skill level>,<delay>,<percent hp>,<percent sp>;
*petskillsupport "<skill name>",<skill level>,<delay>,<percent hp>,<percent sp>;
*petheal <level>,<delay>,<percent hp>,<percent sp>;

This will make the pet use a specified support skill on the owner whenever the 
HP and SP are below the given percent values, with a specified delay time 
between activations. The skill numbers are as per 'db/(pre-)re/skill_db.txt'.
'petheal' works the same as 'petskillsupport' but has the skill ID hard-coded to 
28 (Heal). This command is deprecated.
It's not quite certain who's stats will be used for the skills cast, the 
character's or the pets. Probably, Skotlex can answer that question.

---------------------------------------

*petskillattack <skill id>,<skill level>,<rate>,<bonusrate>;
*petskillattack "<skill name>",<skill level>,<rate>,<bonusrate>;
*petskillattack2 <skill id>,<damage>,<number of attacks>,<rate>,<bonusrate>;
*petskillattack2 "<skill name>",<damage>,<number of attacks>,<rate>,<bonusrate>;

These two commands will make the pet cast an attack skill on the enemy the pet's 
owner is currently fighting. Skill IDs and levels are as per 'petskillsupport'. 
'petskillattack2' will make the pet cast the skill with a fixed amount of damage 
inflicted and the specified number of attacks.

---------------------------------------

===========================
|11.- Homunculus commands.|
===========================
---------------------------------------

*homevolution;

This command will try to evolve the current player's homunculus.
If it doesn't work, the /swt emotion is shown.

To evolve a homunculus, the invoking player must have a homunculus,
the homunculus must not be the last evolution and
the homunculus must have above 91000 intimacy with its owner.

---------------------------------------

*morphembryo;

This command will try to put the invoking player's Homunculus in an
uncallable state, required for mutation into a Homunculus S. The player
will also receive a Strange Embryo (ID 6415) in their inventory if
successful, which is deleted upon mutation.

The command will fail if the invoking player does not have an evolved
Homunculus at level 99 or above. The /swt emotion is shown upon failure.

Returns 1 upon success and 0 for all failures.

---------------------------------------

*hommutate {<ID>};

This command will try to mutate the invoking player's Homunculus into
a Homunculus S. The Strange Embryo (ID 6415) is deleted upon success.

The command will fail if the invoking player does not have an evolved
Homunculus at level 99 or above, if it is not in the embryo state
(from the 'morphembryo' command), or if the invoking player does not
possess a Strange Embryo. The /swt emotion is shown upon failure.

If the optional parameter <ID> is set, the invoking player's Homunculus
will change into the specified Homunculus ID. Otherwise, a random Homunculus S
will be chosen. See 'db/homunculus_db.txt' for a full list of IDs.

Returns 1 upon success and 0 for all failures.

---------------------------------------

*checkhomcall()

This function checks if the attached player's Homunculus is active,
and will return the following values:
 -1: The player has no Homunculus.
  0: The player's Homunculus is active.
  1: The player's Homunculus is vaporized.
  2: The player's Homunculus is in morph state.

---------------------------------------

*gethominfo(<type>)

This function will return Homunculus information for the Homunculus of the
invoking character, regardless of its vaporize state. It returns zero or
"null" if the player does not own a Homunculus.

Valid types are:
 0 - Homunculus unique ID
 1 - Homunculus Class
 2 - Name
 3 - Friendly level (intimacy score). 100000 is full loyalty.
 4 - Hungry level. 100 is completely full.
 5 - Rename flag. 0 means this homunculus has not been named yet.
 6 - Homunculus level

---------------------------------------

*homshuffle;

This will recalculate the homunculus stats according to its level, of the 
current invoking character.

---------------------------------------

==========================
|12.- Mercenary commands.|
==========================
---------------------------------------

*mercenary_create <class>,<contract time>;

This command summons a mercenary for a given time (in milliseconds). For a
list of all available classes, see 'db/mercenary_db.txt'.

This command is typically used in item scripts of mercenary scrolls.

---------------------------------------

*mercenary_heal <hp>,<sp>;

This command works like 'heal', but affects the mercenary of the
currently attached character.

---------------------------------------

*mercenary_sc_start <type>,<tick>,<val1>;

This command works like 'sc_start', but affects the mercenary of the
currently attached character.

---------------------------------------

*mercenary_get_calls(<guild>);
*mercenary_set_calls <guild>,<value>;

Sets or gets the mercenary calls value for given guild for currently
attached character. Guild can be one or the following constants:

    ARCH_MERC_GUILD
    SPEAR_MERC_GUILD
    SWORD_MERC_GUILD

---------------------------------------

*mercenary_get_faith(<guild>);
*mercenary_set_faith <guild>,<value>;

Sets or gets the mercenary faith value for given guild for currently
attached character. Guild can be one or the following constants:

    ARCH_MERC_GUILD
    SPEAR_MERC_GUILD
    SWORD_MERC_GUILD

---------------------------------------

*getmercinfo(<type>{,<char id>});

Retrieves information about mercenary of the currently attached
character. If char id is given, the information of that character is
retrieved instead. Type specifies what information to retrieve and
can be one of the following:

    0 - Database ID
    1 - Class
    2 - Name
    3 - Faith value for this mercenary's guild, if any
    4 - Calls value for this mercenary's guild, if any
    5 - Kill count
    6 - Remaining life time in msec
    7 - Level

If the character does not have a mercenary, the command returns ""
for name and 0 for all other types.

---------------------------------------

======================
|13.- Party commands.|
======================
---------------------------------------

*getpartyname(<party id>)

This function will return the name of a party that has the specified ID number. 
If there is no such party ID, "null" will be returned.

Lets say the ID of a party was saved as a global variable:

    // This would return the name of the party from the ID stored in a variable
    mes "You're in the '"+getpartyname($@var)+"' party, I know!";

---------------------------------------

*getpartymember <party id>{,<type>};

This command will find all members of a specified party and returns their names 
(or character id or account id depending on the value of "type") into an array
of temporary global variables. There's actually quite a few commands like this
which will fill a special variable with data upon execution and not do anything
else.

Upon executing this,

$@partymembername$[] is a global temporary string array which contains all the 
                     names of these party members
                     (only set when type is 0 or not specified)

$@partymembercid[]   is a global temporary number array which contains the 
                     character id of these party members.
                     (only set when type is 1)

$@partymemberaid[]   is a global temporary number array which contains the 
                     account id of these party members.
                     (only set when type is 2)

$@partymembercount   is the number of party members that were found.

The party members will (apparently) be found regardless of whether they are 
online or offline. Note that the names come in no particular order.

Be sure to use $@partymembercount to go through this array, and not 
'getarraysize', because it is not cleared between runs of 'getpartymember'. If 
someone with 7 party members invokes this script, the array would have 7 
elements. But if another person calls up the NPC, and he has a party of 5, the 
server will not clear the array for you, overwriting the values instead. So in 
addition to returning the 5 member names, the 6th and 7th elements from the last 
call remain, and you will get 5+2 members, of which the last 2 don't belong to 
the new guy's party. $@partymembercount will always contain the correct number, 
(5) unlike 'getarraysize()' which will return 7 in this case.

Example 1: list party member names

	// get the party member names
	getpartymember getcharid(1),0;
	
	// It's a good idea to copy the global temporary $@partymember***** 
	// variables to your own scope variables because if you have pauses in this 
	// script (sleep, sleep2, next, close2, input, menu, select, or prompt), 
	// another player could click this NPC, trigger 'getpartymember', and 
	// overwrite the $@partymember***** variables.
	.@count = $@partymembercount;
	copyarray .@name$[0], $@partymembername$[0], $@partymembercount;
	
	// list the party member names
	for (.@i = 0; .@i < .@count; .@i++)
		mes (.@i +1) + ". ^0000FF" + .@name$[.@i] + "^000000";
	close;


Example 2: check party count (with a 'next' pause), before warping to event

	.register_num = 5; // How many party members are required?
	
	// get the charID and accountID of character's party members
	getpartymember getcharid(1), 1;
	getpartymember getcharid(1), 2;
	
	if ( $@partymembercount != .register_num ) {
		mes "Please form a party of "+ .register_num +" to continue";
		close;
	}
	
	// loop through both and use 'isloggedin' to count online party members
	for ( .@i = 0; .@i < $@partymembercount; .@i++ )
		if ( isloggedin( $@partymemberaid[.@i], $@partymembercid[.@i] ) )
			.@count_online++;

	// We search accountID & charID because a single party can have multiple 
	// characters from the same account. Without searching through the charID, 
	// if a player has 2 characters from the same account inside the party but 
	// only 1 char online, it would count their online char twice.
	
	if ( .@count_online != .register_num ) {
		mes "All your party members must be online to continue";
		close;
	}
	
	// copy the array to prevent players cheating the system
	copyarray .@partymembercid, $@partymembercid, .register_num;
	
	mes "Are you ready ?";
	next; // careful here
	select("Yes");
	
	// When a script hits a next, menu, sleep or input that pauses the script, 
	// players can invite or /leave and make changes in their party. To prevent 
	// this, we call getpartymember again and compare with the original values.
	
	getpartymember getcharid(1), 1;
	if ( $@partymembercount != .register_num ) {
		mes "You've made changes to your party !";
		close;
	}
	for ( .@i = 0; .@i < $@partymembercount; .@i++ ) {
		if ( .@partymembercid[.@i] != $@partymembercid[.@i] ) {
			mes "You've made changes to your party !";
			close;
		}
	}
	
	// Finally, it's safe to start the event!
	warpparty "event_map", 0,0, getcharid(1);

---------------------------------------

*getpartyleader(<party id>{,<type>})

This function returns some information about the given party-id's leader.
When type is omitted, the default information retrieved is the leader's name.
Possible types are:

	1: Leader account id
	2: Leader character id
	3: Leader's class
	4: Leader's current map name
	5: Leader's current level as stored on the party structure (may not be
	   current level if leader leveled up recently).

If retrieval fails (leader not found or party does not exist), this function
returns "null" instead of the character name, and -1 for the other types.

---------------------------------------

*party_create("<party name>"{,<character id>{,<item share>,<item share type>}});

Organizes a party with the attached or specified character as leader. If
successful, the command returns 1 and sets the global temporary variable
"$@party_create_id" to the ID of the party created.

Additionally, item sharing options can be provided:
 - Item Share: 0-Each Take (default), 1-Party Share
 - Item Share Type: 0-Each Take (default), 1-Even Share

These values are returned upon failure:
 0: Unknown error.
-1: Player not found.
-2: Player already has a party.
-3: Party name exists.

---------------------------------------

*party_destroy(<party id>);

Disbands a party. The command returns 1 upon success and 0 upon failure.

---------------------------------------

*party_addmember(<party id>,<character id>);

Adds a player to an existing party.

The command returns 1 upon success, and these values upon failure:
 0: Unknown error.
-1: Player not found.
-2: Player already has a party.
-3: Party not found.
-4: Party is full.

---------------------------------------

*party_delmember({<character id>,<party id>});

Removes a player from his/her party. If no player is specified, the command
will run for the invoking player. If that player is the only party member
remaining, the party will be disbanded.

The command returns 1 upon success, and these values upon failure:
 0: Unknown error.
-1: Player not found.
-2: Party not found.
-3: Player is not in the party.

---------------------------------------

*party_changeleader(<party id>,<character id>);

Transfers leadership of a party to the specified character.

The command returns 1 upon success, and these values upon failure:
 0: Unknown error.
-1: Party not found.
-2: Player not found.
-3: Player is not in the party.
-4: Player is already party leader.

---------------------------------------

*party_changeoption(<party id>,<option>,<flag>);

Changes a party option.

Valid options are:
 0 - Exp Share (flags: 0-Each Take, 1-Even Share)
 1 - Item Share (flags: 0-Each Take, 1-Party Share)
 2 - Item Share Type (flags: 0-Each Take, 1-Even Share)

The command returns 1 upon success, and these values upon failure:
 0: Invalid option.
-1: Party not found.

---------------------------------------

Whew.
That's about all of them.
